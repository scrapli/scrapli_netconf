<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>scrapli_netconf.channel.async_channel API documentation</title>
<meta name="description" content="scrapli_netconf.channel.async_channel" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_netconf.channel.async_channel</code></h1>
</header>
<section id="section-intro">
<p>scrapli_netconf.channel.async_channel</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_netconf.channel.async_channel&#34;&#34;&#34;
import asyncio

from scrapli.channel import AsyncChannel
from scrapli.channel.base_channel import BaseChannelArgs
from scrapli.decorators import ChannelTimeout
from scrapli.transport.base.async_transport import AsyncTransport
from scrapli_netconf.channel.base_channel import BaseNetconfChannel, NetconfBaseChannelArgs
from scrapli_netconf.constants import NetconfVersion


class AsyncNetconfChannel(AsyncChannel, BaseNetconfChannel):
    def __init__(
        self,
        transport: AsyncTransport,
        base_channel_args: BaseChannelArgs,
        netconf_base_channel_args: NetconfBaseChannelArgs,
    ):
        super().__init__(transport=transport, base_channel_args=base_channel_args)

        self._netconf_base_channel_args = netconf_base_channel_args

        # always use `]]&gt;]]&gt;` as the initial prompt to match
        self._base_channel_args.comms_prompt_pattern = &#34;]]&gt;]]&gt;&#34;
        self._server_echo = False
        self._capabilities_buf = b&#34;&#34;

    async def open_netconf(self) -&gt; None:
        &#34;&#34;&#34;
        Open the netconf channel

        Args:
            N/A

        Returns:
            None

        Raises:
            N/A

        &#34;&#34;&#34;
        raw_server_capabilities = await self._get_server_capabilities()

        self._process_capabilities_exchange(raw_server_capabilities=raw_server_capabilities)

        await self._check_echo()
        await self._send_client_capabilities()

    async def _check_echo(self) -&gt; None:
        &#34;&#34;&#34;
        Determine if inputs are &#34;echoed&#34; back on stdout

        At least per early drafts of the netconf over ssh rfcs the netconf servers MUST NOT echo the
        input commands back to the client. In the case of &#34;normal&#34; scrapli netconf with the system
        transport this happens anyway because we combine the stdin and stdout fds into a single pty,
        however for other transports we have an actual stdin and stdout fd to read/write. It seems
        that at the very least IOSXE with NETCONF 1.1 seems to want to echo inputs back onto to the
        stdout for the channel. This is totally ok and we can deal with it, we just need to *know*
        that it is happening and that gives us somewhat of a dilemma... we want to give the device
        time to echo this data back to us, but we also dont want to just arbitrarily wait
        (especially in the more common case where the device is *not* echoing anything back). So we
        take 1/20th of the transport timeout and we wait that long to see -- if we get echo, we
        return immediately of course, otherwise there is an unfortunate slight delay here :(

        See: https://tools.ietf.org/html/draft-ietf-netconf-ssh-02 (search for &#34;echo&#34;)

        Args:
             timeout_transport: transport timeout value to modify to use as timeout to test echo

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        try:
            await asyncio.wait_for(self.read(), timeout=self._base_channel_args.timeout_ops / 20)
            self.logger.info(
                &#34;Determined that server echoes inputs on stdout, setting `_server_echo` to `True`&#34;
            )
            self._server_echo = True
        except asyncio.exceptions.TimeoutError:
            pass
        return

    @ChannelTimeout(
        &#34;timed out determining if session is authenticated/getting server capabilities&#34;,
    )
    async def _get_server_capabilities(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read until all server capabilities have been sent by server

        Args:
            N/A

        Returns:
            bytes: raw bytes containing server capabilities

        Raises:
            N/A

        &#34;&#34;&#34;
        capabilities_buf = self._capabilities_buf

        # reset this to empty to avoid any confusion now that we are moving on
        self._capabilities_buf = b&#34;&#34;

        # not sure why scrapli core is happy w/ the type stubs for all this but scrapli netconf
        # is furious... fix this at some point!
        async with self._channel_lock():  # type: ignore
            while b&#34;]]&gt;]]&gt;&#34; not in capabilities_buf:
                capabilities_buf += await self.read()
            self.logger.debug(f&#34;received raw server capabilities: {repr(capabilities_buf)}&#34;)
        return capabilities_buf

    @ChannelTimeout(&#34;timed out sending client capabilities&#34;)
    async def _send_client_capabilities(
        self,
    ) -&gt; None:
        &#34;&#34;&#34;
        Send client capabilities to the netconf server

        Args:
            N/A

        Returns:
            None

        Raises:
            N/A

        &#34;&#34;&#34;
        # not sure why scrapli core is happy w/ the type stubs for all this but scrapli netconf
        # is furious... fix this at some point!
        async with self._channel_lock():  # type: ignore
            _ = self._pre_send_client_capabilities(
                client_capabilities=self._netconf_base_channel_args.client_capabilities
            )
            self.send_return()

    async def _read_until_input(self, channel_input: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        Async read until all input has been entered.

        Args:
            channel_input: string to write to channel

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        &#34;&#34;&#34;
        output = b&#34;&#34;

        if self._server_echo is False:
            return output

        if not channel_input:
            self.logger.info(f&#34;Read: {repr(output)}&#34;)
            return output

        while True:
            output += await self.read()

            if channel_input in output:
                break

        self.logger.info(f&#34;Read: {repr(output)}&#34;)
        return output

    async def send_input_netconf(self, channel_input: str) -&gt; bytes:
        &#34;&#34;&#34;
        Send inputs to netconf server

        Args:
            channel_input: string of the base xml message to send to netconf server

        Returns:
            bytes: bytes result of message sent to netconf server

        Raises:
            N/A

        &#34;&#34;&#34;
        final_channel_input = self._build_message(channel_input)
        bytes_final_channel_input = final_channel_input.encode()

        buf, _ = await super().send_input(
            channel_input=final_channel_input, strip_prompt=False, eager=True
        )

        if bytes_final_channel_input in buf:
            buf = buf.split(bytes_final_channel_input)[1]

        buf = await self._read_until_prompt(buf=buf)

        if self._netconf_base_channel_args.netconf_version == NetconfVersion.VERSION_1_1:
            # netconf 1.1 with &#34;chunking&#34; style message format needs an extra return char here
            self.send_return()

        return buf</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_netconf.channel.async_channel.AsyncNetconfChannel"><code class="flex name class">
<span>class <span class="ident">AsyncNetconfChannel</span></span>
<span>(</span><span>transport: scrapli.transport.base.async_transport.AsyncTransport, base_channel_args: scrapli.channel.base_channel.BaseChannelArgs, netconf_base_channel_args: <a title="scrapli_netconf.channel.base_channel.NetconfBaseChannelArgs" href="base_channel.html#scrapli_netconf.channel.base_channel.NetconfBaseChannelArgs">NetconfBaseChannelArgs</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>BaseChannel Object &ndash; provides convenience methods to both sync and async Channels</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong></dt>
<dd>initialized scrapli Transport/AsyncTransport object</dd>
<dt><strong><code>base_channel_args</code></strong></dt>
<dd>BaseChannelArgs object</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncNetconfChannel(AsyncChannel, BaseNetconfChannel):
    def __init__(
        self,
        transport: AsyncTransport,
        base_channel_args: BaseChannelArgs,
        netconf_base_channel_args: NetconfBaseChannelArgs,
    ):
        super().__init__(transport=transport, base_channel_args=base_channel_args)

        self._netconf_base_channel_args = netconf_base_channel_args

        # always use `]]&gt;]]&gt;` as the initial prompt to match
        self._base_channel_args.comms_prompt_pattern = &#34;]]&gt;]]&gt;&#34;
        self._server_echo = False
        self._capabilities_buf = b&#34;&#34;

    async def open_netconf(self) -&gt; None:
        &#34;&#34;&#34;
        Open the netconf channel

        Args:
            N/A

        Returns:
            None

        Raises:
            N/A

        &#34;&#34;&#34;
        raw_server_capabilities = await self._get_server_capabilities()

        self._process_capabilities_exchange(raw_server_capabilities=raw_server_capabilities)

        await self._check_echo()
        await self._send_client_capabilities()

    async def _check_echo(self) -&gt; None:
        &#34;&#34;&#34;
        Determine if inputs are &#34;echoed&#34; back on stdout

        At least per early drafts of the netconf over ssh rfcs the netconf servers MUST NOT echo the
        input commands back to the client. In the case of &#34;normal&#34; scrapli netconf with the system
        transport this happens anyway because we combine the stdin and stdout fds into a single pty,
        however for other transports we have an actual stdin and stdout fd to read/write. It seems
        that at the very least IOSXE with NETCONF 1.1 seems to want to echo inputs back onto to the
        stdout for the channel. This is totally ok and we can deal with it, we just need to *know*
        that it is happening and that gives us somewhat of a dilemma... we want to give the device
        time to echo this data back to us, but we also dont want to just arbitrarily wait
        (especially in the more common case where the device is *not* echoing anything back). So we
        take 1/20th of the transport timeout and we wait that long to see -- if we get echo, we
        return immediately of course, otherwise there is an unfortunate slight delay here :(

        See: https://tools.ietf.org/html/draft-ietf-netconf-ssh-02 (search for &#34;echo&#34;)

        Args:
             timeout_transport: transport timeout value to modify to use as timeout to test echo

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        try:
            await asyncio.wait_for(self.read(), timeout=self._base_channel_args.timeout_ops / 20)
            self.logger.info(
                &#34;Determined that server echoes inputs on stdout, setting `_server_echo` to `True`&#34;
            )
            self._server_echo = True
        except asyncio.exceptions.TimeoutError:
            pass
        return

    @ChannelTimeout(
        &#34;timed out determining if session is authenticated/getting server capabilities&#34;,
    )
    async def _get_server_capabilities(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read until all server capabilities have been sent by server

        Args:
            N/A

        Returns:
            bytes: raw bytes containing server capabilities

        Raises:
            N/A

        &#34;&#34;&#34;
        capabilities_buf = self._capabilities_buf

        # reset this to empty to avoid any confusion now that we are moving on
        self._capabilities_buf = b&#34;&#34;

        # not sure why scrapli core is happy w/ the type stubs for all this but scrapli netconf
        # is furious... fix this at some point!
        async with self._channel_lock():  # type: ignore
            while b&#34;]]&gt;]]&gt;&#34; not in capabilities_buf:
                capabilities_buf += await self.read()
            self.logger.debug(f&#34;received raw server capabilities: {repr(capabilities_buf)}&#34;)
        return capabilities_buf

    @ChannelTimeout(&#34;timed out sending client capabilities&#34;)
    async def _send_client_capabilities(
        self,
    ) -&gt; None:
        &#34;&#34;&#34;
        Send client capabilities to the netconf server

        Args:
            N/A

        Returns:
            None

        Raises:
            N/A

        &#34;&#34;&#34;
        # not sure why scrapli core is happy w/ the type stubs for all this but scrapli netconf
        # is furious... fix this at some point!
        async with self._channel_lock():  # type: ignore
            _ = self._pre_send_client_capabilities(
                client_capabilities=self._netconf_base_channel_args.client_capabilities
            )
            self.send_return()

    async def _read_until_input(self, channel_input: bytes) -&gt; bytes:
        &#34;&#34;&#34;
        Async read until all input has been entered.

        Args:
            channel_input: string to write to channel

        Returns:
            bytes: output read from channel

        Raises:
            N/A

        &#34;&#34;&#34;
        output = b&#34;&#34;

        if self._server_echo is False:
            return output

        if not channel_input:
            self.logger.info(f&#34;Read: {repr(output)}&#34;)
            return output

        while True:
            output += await self.read()

            if channel_input in output:
                break

        self.logger.info(f&#34;Read: {repr(output)}&#34;)
        return output

    async def send_input_netconf(self, channel_input: str) -&gt; bytes:
        &#34;&#34;&#34;
        Send inputs to netconf server

        Args:
            channel_input: string of the base xml message to send to netconf server

        Returns:
            bytes: bytes result of message sent to netconf server

        Raises:
            N/A

        &#34;&#34;&#34;
        final_channel_input = self._build_message(channel_input)
        bytes_final_channel_input = final_channel_input.encode()

        buf, _ = await super().send_input(
            channel_input=final_channel_input, strip_prompt=False, eager=True
        )

        if bytes_final_channel_input in buf:
            buf = buf.split(bytes_final_channel_input)[1]

        buf = await self._read_until_prompt(buf=buf)

        if self._netconf_base_channel_args.netconf_version == NetconfVersion.VERSION_1_1:
            # netconf 1.1 with &#34;chunking&#34; style message format needs an extra return char here
            self.send_return()

        return buf</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.channel.async_channel.AsyncChannel</li>
<li><a title="scrapli_netconf.channel.base_channel.BaseNetconfChannel" href="base_channel.html#scrapli_netconf.channel.base_channel.BaseNetconfChannel">BaseNetconfChannel</a></li>
<li>scrapli.channel.base_channel.BaseChannel</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli_netconf.channel.async_channel.AsyncNetconfChannel.open_netconf"><code class="name flex">
<span>async def <span class="ident">open_netconf</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open the netconf channel</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open_netconf(self) -&gt; None:
    &#34;&#34;&#34;
    Open the netconf channel

    Args:
        N/A

    Returns:
        None

    Raises:
        N/A

    &#34;&#34;&#34;
    raw_server_capabilities = await self._get_server_capabilities()

    self._process_capabilities_exchange(raw_server_capabilities=raw_server_capabilities)

    await self._check_echo()
    await self._send_client_capabilities()</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.channel.async_channel.AsyncNetconfChannel.send_input_netconf"><code class="name flex">
<span>async def <span class="ident">send_input_netconf</span></span>(<span>self, channel_input: str) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Send inputs to netconf server</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_input</code></strong></dt>
<dd>string of the base xml message to send to netconf server</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bytes</code></dt>
<dd>bytes result of message sent to netconf server</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def send_input_netconf(self, channel_input: str) -&gt; bytes:
    &#34;&#34;&#34;
    Send inputs to netconf server

    Args:
        channel_input: string of the base xml message to send to netconf server

    Returns:
        bytes: bytes result of message sent to netconf server

    Raises:
        N/A

    &#34;&#34;&#34;
    final_channel_input = self._build_message(channel_input)
    bytes_final_channel_input = final_channel_input.encode()

    buf, _ = await super().send_input(
        channel_input=final_channel_input, strip_prompt=False, eager=True
    )

    if bytes_final_channel_input in buf:
        buf = buf.split(bytes_final_channel_input)[1]

    buf = await self._read_until_prompt(buf=buf)

    if self._netconf_base_channel_args.netconf_version == NetconfVersion.VERSION_1_1:
        # netconf 1.1 with &#34;chunking&#34; style message format needs an extra return char here
        self.send_return()

    return buf</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_netconf.channel" href="index.html">scrapli_netconf.channel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_netconf.channel.async_channel.AsyncNetconfChannel" href="#scrapli_netconf.channel.async_channel.AsyncNetconfChannel">AsyncNetconfChannel</a></code></h4>
<ul class="">
<li><code><a title="scrapli_netconf.channel.async_channel.AsyncNetconfChannel.open_netconf" href="#scrapli_netconf.channel.async_channel.AsyncNetconfChannel.open_netconf">open_netconf</a></code></li>
<li><code><a title="scrapli_netconf.channel.async_channel.AsyncNetconfChannel.send_input_netconf" href="#scrapli_netconf.channel.async_channel.AsyncNetconfChannel.send_input_netconf">send_input_netconf</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>