<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>scrapli_netconf.channel.base_channel API documentation</title>
<meta name="description" content="scrapli_netconf.channel.base_channel" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_netconf.channel.base_channel</code></h1>
</header>
<section id="section-intro">
<p>scrapli_netconf.channel.base_channel</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_netconf.channel.base_channel&#34;&#34;&#34;
from scrapli.channel.base_channel import ChannelBase
from scrapli_netconf.constants import NetconfVersion
from scrapli_netconf.driver.base_driver import NetconfClientCapabilities


class NetconfChannelBase(ChannelBase):
    netconf_version: NetconfVersion

    def _restructure_output(self, output: bytes, strip_prompt: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        Override scrapli _restructure_output as this is unnecessary for scrapli_netconf

        Args:
            output: bytes from channel
            strip_prompt: ignored in this base class; for LSP reasons for subclasses

        Returns:
            bytes: output of joined output lines optionally with prompt removed

        Raises:
            N/A

        &#34;&#34;&#34;
        _ = strip_prompt
        return output

    def _build_message(self, channel_input: str) -&gt; str:
        &#34;&#34;&#34;
        Build formatted message to send to netconf server

        Args:
            channel_input: string of the base xml message to send to netconf server

        Returns:
            str: string of formatted message to send to netconf server

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.netconf_version == NetconfVersion.VERSION_1_1:
            msg_template = &#34;#{}\n{}\n##&#34;
            # format message for chunk message types
            final_channel_input = msg_template.format(len(channel_input), channel_input)
            return final_channel_input

        # some (vMX for some reason?) devices seem to get carried away if there are *any* returns in
        # the input... this causes the server to output the rpc result which breaks the normal
        # scrapli &#34;read_until_input&#34; behavior, so we&#39;ll simply remove new lines in channel inputs
        return channel_input.replace(&#34;\n&#34;, &#34;&#34;)

    def _pre_send_client_capabilities(
        self, client_capabilities: NetconfClientCapabilities
    ) -&gt; bytes:
        &#34;&#34;&#34;
        Handle pre &#34;_send_client_capabilities&#34; tasks for consistency between sync/async versions

        Args:
            client_capabilities: string of client netconf capabilities to send to server

        Returns:
            bytes: bytes of client capabilities to send to the channel

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(&#34;Sending client capabilities&#34;)
        self.transport.session_lock.acquire()
        bytes_client_capabilities: bytes = client_capabilities.value.encode().strip()
        self.logger.debug(f&#34;Attempting to send capabilities: {client_capabilities}&#34;)
        self.transport.write(client_capabilities.value)
        self.logger.debug(f&#34;Write: {repr(client_capabilities.value)}&#34;)
        return bytes_client_capabilities

    def _post_send_client_capabilities(
        self, capabilities_version: NetconfVersion = NetconfVersion.VERSION_1_1
    ) -&gt; None:
        &#34;&#34;&#34;
        Handle pre &#34;_send_client_capabilities&#34; tasks for consistency between sync/async versions

        Args:
            capabilities_version: string of client netconf capabilities version, 1.0 or 1.1

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if capabilities_version == NetconfVersion.VERSION_1_1:
            self.netconf_version = NetconfVersion.VERSION_1_1
            self.comms_prompt_pattern = r&#34;^##$&#34;

        self.transport.session_lock.release()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_netconf.channel.base_channel.NetconfChannelBase"><code class="flex name class">
<span>class <span class="ident">NetconfChannelBase</span></span>
<span>(</span><span>transport: Union[scrapli.transport.transport.Transport, scrapli.transport.async_transport.AsyncTransport], comms_prompt_pattern: str = &#x27;^[a-z0-9.\\-@()/:]{1,32}[#&gt;$]$&#x27;, comms_return_char: str = '\n', comms_ansi: bool = False, comms_auto_expand: bool = False, timeout_ops: float = 10)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Channel Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transport</code></strong></dt>
<dd>Transport object of any transport provider (system|telnet or a plugin)
transport could in theory be any transport as long as it provides a read and a write
method&hellip; obviously its probably always going to be scrapli transport though</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; use <code>^</code> and <code>$</code> for multi-line!</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>character to use to send returns to host</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output</dd>
<dt><strong><code>comms_auto_expand</code></strong></dt>
<dd>bool to indicate if a device auto-expands commands, for example
juniper devices without <code>cli complete-on-space</code> disabled will convert <code>config</code> to
<code>configuration</code> after entering a space character after <code>config</code>; because scrapli
reads the channel until each command is entered, the command changing from <code>config</code>
to <code>configuration</code> will cause scrapli (by default) to never think the command has
been entered. Setting this value to <code>True</code> will force scrapli to zip the split lists
of inputs and outputs together to determine if each read output starts with the
corresponding input. For example, if the inputs are "sho ver" and the read output is
"show version", scrapli will zip the split strings together and confirm that in fact
"show" starts with "sho" and "version" starts with "ver", confirming that the
commands that were input were input properly. This is disabled by default, as it is
preferable to disable this type of behavior via the device itself if possible.</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout in seconds for channel operations (reads/writes)</dd>
</dl>
<h2 id="args_1">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetconfChannelBase(ChannelBase):
    netconf_version: NetconfVersion

    def _restructure_output(self, output: bytes, strip_prompt: bool = False) -&gt; bytes:
        &#34;&#34;&#34;
        Override scrapli _restructure_output as this is unnecessary for scrapli_netconf

        Args:
            output: bytes from channel
            strip_prompt: ignored in this base class; for LSP reasons for subclasses

        Returns:
            bytes: output of joined output lines optionally with prompt removed

        Raises:
            N/A

        &#34;&#34;&#34;
        _ = strip_prompt
        return output

    def _build_message(self, channel_input: str) -&gt; str:
        &#34;&#34;&#34;
        Build formatted message to send to netconf server

        Args:
            channel_input: string of the base xml message to send to netconf server

        Returns:
            str: string of formatted message to send to netconf server

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.netconf_version == NetconfVersion.VERSION_1_1:
            msg_template = &#34;#{}\n{}\n##&#34;
            # format message for chunk message types
            final_channel_input = msg_template.format(len(channel_input), channel_input)
            return final_channel_input

        # some (vMX for some reason?) devices seem to get carried away if there are *any* returns in
        # the input... this causes the server to output the rpc result which breaks the normal
        # scrapli &#34;read_until_input&#34; behavior, so we&#39;ll simply remove new lines in channel inputs
        return channel_input.replace(&#34;\n&#34;, &#34;&#34;)

    def _pre_send_client_capabilities(
        self, client_capabilities: NetconfClientCapabilities
    ) -&gt; bytes:
        &#34;&#34;&#34;
        Handle pre &#34;_send_client_capabilities&#34; tasks for consistency between sync/async versions

        Args:
            client_capabilities: string of client netconf capabilities to send to server

        Returns:
            bytes: bytes of client capabilities to send to the channel

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(&#34;Sending client capabilities&#34;)
        self.transport.session_lock.acquire()
        bytes_client_capabilities: bytes = client_capabilities.value.encode().strip()
        self.logger.debug(f&#34;Attempting to send capabilities: {client_capabilities}&#34;)
        self.transport.write(client_capabilities.value)
        self.logger.debug(f&#34;Write: {repr(client_capabilities.value)}&#34;)
        return bytes_client_capabilities

    def _post_send_client_capabilities(
        self, capabilities_version: NetconfVersion = NetconfVersion.VERSION_1_1
    ) -&gt; None:
        &#34;&#34;&#34;
        Handle pre &#34;_send_client_capabilities&#34; tasks for consistency between sync/async versions

        Args:
            capabilities_version: string of client netconf capabilities version, 1.0 or 1.1

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if capabilities_version == NetconfVersion.VERSION_1_1:
            self.netconf_version = NetconfVersion.VERSION_1_1
            self.comms_prompt_pattern = r&#34;^##$&#34;

        self.transport.session_lock.release()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.channel.base_channel.ChannelBase</li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli_netconf.channel.async_channel.AsyncNetconfChannel" href="async_channel.html#scrapli_netconf.channel.async_channel.AsyncNetconfChannel">AsyncNetconfChannel</a></li>
<li><a title="scrapli_netconf.channel.channel.NetconfChannel" href="channel.html#scrapli_netconf.channel.channel.NetconfChannel">NetconfChannel</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli_netconf.channel.base_channel.NetconfChannelBase.netconf_version"><code class="name">var <span class="ident">netconf_version</span> : <a title="scrapli_netconf.constants.NetconfVersion" href="../constants.html#scrapli_netconf.constants.NetconfVersion">NetconfVersion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_netconf.channel" href="index.html">scrapli_netconf.channel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_netconf.channel.base_channel.NetconfChannelBase" href="#scrapli_netconf.channel.base_channel.NetconfChannelBase">NetconfChannelBase</a></code></h4>
<ul class="">
<li><code><a title="scrapli_netconf.channel.base_channel.NetconfChannelBase.netconf_version" href="#scrapli_netconf.channel.base_channel.NetconfChannelBase.netconf_version">netconf_version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>