<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>scrapli_netconf.driver.async_driver API documentation</title>
<meta name="description" content="scrapli_netconf.driver.async_driver" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_netconf.driver.async_driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli_netconf.driver.async_driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_netconf.driver.async_driver&#34;&#34;&#34;
from typing import Any, Callable, Dict, List, Optional, Union
from warnings import warn

from scrapli import AsyncDriver
from scrapli_netconf.channel.async_channel import AsyncNetconfChannel
from scrapli_netconf.channel.base_channel import NetconfBaseChannelArgs
from scrapli_netconf.constants import NetconfVersion
from scrapli_netconf.driver.base_driver import NetconfBaseDriver
from scrapli_netconf.response import NetconfResponse


class AsyncNetconfDriver(AsyncDriver, NetconfBaseDriver):
    def __init__(
        self,
        host: str,
        port: int = 830,
        strip_namespaces: bool = False,
        strict_datastores: bool = False,
        auth_username: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_private_key: str = &#34;&#34;,
        auth_private_key_passphrase: str = &#34;&#34;,
        auth_strict_key: bool = True,
        auth_bypass: bool = False,
        timeout_socket: float = 15.0,
        timeout_transport: float = 30.0,
        timeout_ops: float = 30.0,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,48}[#&gt;$]\s*$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
        ssh_config_file: Union[str, bool] = False,
        ssh_known_hosts_file: Union[str, bool] = False,
        on_init: Optional[Callable[..., Any]] = None,
        on_open: Optional[Callable[..., Any]] = None,
        on_close: Optional[Callable[..., Any]] = None,
        transport: str = &#34;system&#34;,
        transport_options: Optional[Dict[str, Any]] = None,
        channel_log: Union[str, bool] = False,
        channel_lock: bool = False,
    ) -&gt; None:
        super().__init__(
            host=host,
            port=port,
            auth_username=auth_username,
            auth_password=auth_password,
            auth_private_key=auth_private_key,
            auth_private_key_passphrase=auth_private_key_passphrase,
            auth_strict_key=auth_strict_key,
            auth_bypass=auth_bypass,
            timeout_socket=timeout_socket,
            timeout_transport=timeout_transport,
            timeout_ops=timeout_ops,
            comms_prompt_pattern=comms_prompt_pattern,
            comms_return_char=comms_return_char,
            comms_ansi=comms_ansi,
            ssh_config_file=ssh_config_file,
            ssh_known_hosts_file=ssh_known_hosts_file,
            on_init=on_init,
            on_open=on_open,
            on_close=on_close,
            transport=transport,
            transport_options=transport_options,
            channel_log=channel_log,
            channel_lock=channel_lock,
        )
        self._netconf_base_channel_args = NetconfBaseChannelArgs(
            netconf_version=NetconfVersion.UNKNOWN
        )
        self.channel = AsyncNetconfChannel(
            transport=self.transport,
            base_channel_args=self._base_channel_args,
            netconf_base_channel_args=self._netconf_base_channel_args,
        )

        self.strip_namespaces = strip_namespaces
        self.strict_datastores = strict_datastores
        self.server_capabilities: List[str] = []
        self.readable_datastores: List[str] = []
        self.writeable_datastores: List[str] = []
        self.message_id = 101

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open netconf connection to server

        Args:
            N/A

        Returns:
            None

        Raises:
            N/A

        &#34;&#34;&#34;
        self._pre_open_closing_log(closing=False)

        await self.transport.open_netconf()
        await self.channel.open_netconf()

        self._build_readable_datastores()
        self._build_writeable_datastores()

        self._post_open_closing_log(closing=False)

    async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get operation

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get(filter_=filter_, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)

        response.record_response(raw_response)
        return response

    async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_edit_config(config=config, target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def delete_config(self, target: str = &#34;candidate&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf delete-config operation

        Args:
            target: configuration source to target; startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_delete_config(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf commit config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_commit()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf discard config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_discard()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf lock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_lock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf unlock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_unlock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;rpc&#34; operation; typically only used with juniper devices

        You can also use this to build send your own payload in a more manual fashion

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_rpc(filter_=filter_)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def validate(self, source: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;validate&#34; operation

        Args:
            source: configuration source to validate; typically one of running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_validate(source=source)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response


# remove in future releases, retaining this to not break end user scripts for now
class AsyncNetconfScrape(AsyncNetconfDriver):
    warning = (
        &#34;`NetconfScrape` has been renamed `NetconfDriver`, `NetconfScrape` will be deprecated in &#34;
        &#34;future releases!&#34;
    )

    def __init_subclass__(cls):
        &#34;&#34;&#34;Deprecate AsyncNetconfScrape&#34;&#34;&#34;
        warn(cls.warning, DeprecationWarning, 2)

    def __new__(cls, *args, **kwargs):
        warn(cls.warning, DeprecationWarning, 2)
        return AsyncNetconfDriver(*args, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver"><code class="flex name class">
<span>class <span class="ident">AsyncNetconfDriver</span></span>
<span>(</span><span>host: str, port: int = 830, strip_namespaces: bool = False, strict_datastores: bool = False, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_prompt_pattern: str = &#x27;^[a-z0-9.\\-@()/:]{1,48}[#&gt;$]\\s*$&#x27;, comms_return_char: str = '\n', comms_ansi: bool = False, ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Union[Callable[..., Any], NoneType] = None, on_open: Union[Callable[..., Any], NoneType] = None, on_close: Union[Callable[..., Any], NoneType] = None, transport: str = 'system', transport_options: Union[Dict[str, Any], NoneType] = None, channel_log: Union[str, bool] = False, channel_lock: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>BaseDriver Object</p>
<p>BaseDriver is the root for all Scrapli driver classes. The synchronous and asyncio driver
base driver classes can be used to provide a semi-pexpect like experience over top of
whatever transport a user prefers. Generally, however, the base driver classes should not be
used directly. It is best to use the GenericDriver (or AsyncGenericDriver) or NetworkDriver
(or AsyncNetworkDriver) sub-classes of the base drivers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_private_key</code></strong></dt>
<dd>path to private key for authentication</dd>
<dt><strong><code>auth_private_key_passphrase</code></strong></dt>
<dd>passphrase for decrypting ssh key if necessary</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>strict host checking or not</dd>
<dt><strong><code>auth_bypass</code></strong></dt>
<dd>bypass "in channel" authentication &ndash; only supported with telnet,
asynctelnet, and system transport plugins</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket/initial connection in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for ssh channel operations</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows
for highly reliably matching for prompts however we do NOT strip trailing whitespace
for each line, so be sure to add '\s?' or similar if your device needs that. This
should be mostly sorted for you if using network drivers (i.e. <code>IOSXEDriver</code>).
Lastly, the case insensitive is just a convenience factor so i can be lazy.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>character to use to send returns to host</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output, generally the default
value of False should be fine</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file, True to use default ssh config file
or False to ignore default ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file, True to use default known
file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</dd>
<dt><strong><code>on_init</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed as the last step of object instantiation &ndash; its purpose is
primarily to provide a mechanism for scrapli community platforms to have an easy way
to modify initialization arguments/object attributes without needing to create a
class that extends the driver, instead allowing the community platforms to simply
build from the GenericDriver or NetworkDriver classes, and pass this callable to do
things such as appending to a username (looking at you RouterOS!!). Note that this
is <em>always</em> a synchronous function (even for asyncio drivers)!</dd>
<dt><strong><code>on_open</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately after authentication is completed. Common use
cases for this callable would be to disable paging or accept any kind of banner
message that prompts a user upon connection</dd>
<dt><strong><code>on_close</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately prior to closing the underlying transport.
Common use cases for this callable would be to save configurations prior to exiting,
or to logout properly to free up vtys or similar</dd>
<dt><strong><code>transport</code></strong></dt>
<dd>name of the transport plugin to use for the actual telnet/ssh/netconf
connection. Available "core" transports are:
- system
- telnet
- asynctelnet
- ssh2
- paramiko
- asyncssh
Please see relevant transport plugin section for details. Additionally third party
transport plugins may be available.</dd>
<dt><strong><code>transport_options</code></strong></dt>
<dd>dictionary of options to pass to selected transport class; see
docs for given transport class for details of what to pass here</dd>
<dt><strong><code>channel_lock</code></strong></dt>
<dd>True/False to lock the channel (threading.Lock/asyncio.Lock) during
any channel operations, defaults to False</dd>
<dt><strong><code>channel_log</code></strong></dt>
<dd>True/False or a string path to a file of where to write out channel logs &ndash;
these are not "logs" in the normal logging module sense, but only the output that is
read from the channel. In other words, the output of the channel log should look
similar to what you would see as a human connecting to a device</dd>
<dt><strong><code>logging_uid</code></strong></dt>
<dd>unique identifier (string) to associate to log messages; useful if you have
multiple connections to the same device (i.e. one console, one ssh, or one to each
supervisor module, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncNetconfDriver(AsyncDriver, NetconfBaseDriver):
    def __init__(
        self,
        host: str,
        port: int = 830,
        strip_namespaces: bool = False,
        strict_datastores: bool = False,
        auth_username: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_private_key: str = &#34;&#34;,
        auth_private_key_passphrase: str = &#34;&#34;,
        auth_strict_key: bool = True,
        auth_bypass: bool = False,
        timeout_socket: float = 15.0,
        timeout_transport: float = 30.0,
        timeout_ops: float = 30.0,
        comms_prompt_pattern: str = r&#34;^[a-z0-9.\-@()/:]{1,48}[#&gt;$]\s*$&#34;,
        comms_return_char: str = &#34;\n&#34;,
        comms_ansi: bool = False,
        ssh_config_file: Union[str, bool] = False,
        ssh_known_hosts_file: Union[str, bool] = False,
        on_init: Optional[Callable[..., Any]] = None,
        on_open: Optional[Callable[..., Any]] = None,
        on_close: Optional[Callable[..., Any]] = None,
        transport: str = &#34;system&#34;,
        transport_options: Optional[Dict[str, Any]] = None,
        channel_log: Union[str, bool] = False,
        channel_lock: bool = False,
    ) -&gt; None:
        super().__init__(
            host=host,
            port=port,
            auth_username=auth_username,
            auth_password=auth_password,
            auth_private_key=auth_private_key,
            auth_private_key_passphrase=auth_private_key_passphrase,
            auth_strict_key=auth_strict_key,
            auth_bypass=auth_bypass,
            timeout_socket=timeout_socket,
            timeout_transport=timeout_transport,
            timeout_ops=timeout_ops,
            comms_prompt_pattern=comms_prompt_pattern,
            comms_return_char=comms_return_char,
            comms_ansi=comms_ansi,
            ssh_config_file=ssh_config_file,
            ssh_known_hosts_file=ssh_known_hosts_file,
            on_init=on_init,
            on_open=on_open,
            on_close=on_close,
            transport=transport,
            transport_options=transport_options,
            channel_log=channel_log,
            channel_lock=channel_lock,
        )
        self._netconf_base_channel_args = NetconfBaseChannelArgs(
            netconf_version=NetconfVersion.UNKNOWN
        )
        self.channel = AsyncNetconfChannel(
            transport=self.transport,
            base_channel_args=self._base_channel_args,
            netconf_base_channel_args=self._netconf_base_channel_args,
        )

        self.strip_namespaces = strip_namespaces
        self.strict_datastores = strict_datastores
        self.server_capabilities: List[str] = []
        self.readable_datastores: List[str] = []
        self.writeable_datastores: List[str] = []
        self.message_id = 101

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open netconf connection to server

        Args:
            N/A

        Returns:
            None

        Raises:
            N/A

        &#34;&#34;&#34;
        self._pre_open_closing_log(closing=False)

        await self.transport.open_netconf()
        await self.channel.open_netconf()

        self._build_readable_datastores()
        self._build_writeable_datastores()

        self._post_open_closing_log(closing=False)

    async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get operation

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get(filter_=filter_, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)

        response.record_response(raw_response)
        return response

    async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_edit_config(config=config, target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def delete_config(self, target: str = &#34;candidate&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf delete-config operation

        Args:
            target: configuration source to target; startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_delete_config(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf commit config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_commit()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf discard config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_discard()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf lock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_lock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf unlock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_unlock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;rpc&#34; operation; typically only used with juniper devices

        You can also use this to build send your own payload in a more manual fashion

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_rpc(filter_=filter_)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response

    async def validate(self, source: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;validate&#34; operation

        Args:
            source: configuration source to validate; typically one of running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_validate(source=source)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response.record_response(raw_response)
        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.driver.base.async_driver.AsyncDriver</li>
<li><a title="scrapli_netconf.driver.base_driver.NetconfBaseDriver" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver">NetconfBaseDriver</a></li>
<li>scrapli.driver.base.base_driver.BaseDriver</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape">AsyncNetconfScrape</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.host"><code class="name">var <span class="ident">host</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.readable_datastores"><code class="name">var <span class="ident">readable_datastores</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.strict_datastores"><code class="name">var <span class="ident">strict_datastores</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.strip_namespaces"><code class="name">var <span class="ident">strip_namespaces</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.writeable_datastores"><code class="name">var <span class="ident">writeable_datastores</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.commit"><code class="name flex">
<span>async def <span class="ident">commit</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf commit config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def commit(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf commit config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_commit()
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.delete_config"><code class="name flex">
<span>async def <span class="ident">delete_config</span></span>(<span>self, target: str = 'candidate') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf delete-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def delete_config(self, target: str = &#34;candidate&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf delete-config operation

    Args:
        target: configuration source to target; startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_delete_config(target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.discard"><code class="name flex">
<span>async def <span class="ident">discard</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf discard config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def discard(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf discard config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_discard()
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.edit_config"><code class="name flex">
<span>async def <span class="ident">edit_config</span></span>(<span>self, config: str, target: str = 'running') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>configuration to send to device</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        config: configuration to send to device
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_edit_config(config=config, target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get"><code class="name flex">
<span>async def <span class="ident">get</span></span>(<span>self, filter_: str, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>string filter to apply to the get</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get operation

    Args:
        filter_: string filter to apply to the get
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get(filter_=filter_, filter_type=filter_type)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get_config"><code class="name flex">
<span>async def <span class="ident">get_config</span></span>(<span>self, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>configuration source to get; typically one of running|startup|candidate</dd>
<dt><strong><code>filters</code></strong></dt>
<dd>string or list of strings of filters to apply to configuration</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_config(
    self,
    source: str = &#34;running&#34;,
    filters: Optional[Union[str, List[str]]] = None,
    filter_type: str = &#34;subtree&#34;,
) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        source: configuration source to get; typically one of running|startup|candidate
        filters: string or list of strings of filters to apply to configuration
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
    raw_response = await self.channel.send_input_netconf(response.channel_input)

    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.lock"><code class="name flex">
<span>async def <span class="ident">lock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf lock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def lock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf lock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_lock(target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open netconf connection to server</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open netconf connection to server

    Args:
        N/A

    Returns:
        None

    Raises:
        N/A

    &#34;&#34;&#34;
    self._pre_open_closing_log(closing=False)

    await self.transport.open_netconf()
    await self.channel.open_netconf()

    self._build_readable_datastores()
    self._build_writeable_datastores()

    self._post_open_closing_log(closing=False)</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.rpc"><code class="name flex">
<span>async def <span class="ident">rpc</span></span>(<span>self, filter_: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf "rpc" operation; typically only used with juniper devices</p>
<p>You can also use this to build send your own payload in a more manual fashion</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>filter/rpc to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def rpc(self, filter_: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf &#34;rpc&#34; operation; typically only used with juniper devices

    You can also use this to build send your own payload in a more manual fashion

    Args:
        filter_: filter/rpc to execute

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_rpc(filter_=filter_)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.unlock"><code class="name flex">
<span>async def <span class="ident">unlock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf unlock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unlock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf unlock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_unlock(target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.validate"><code class="name flex">
<span>async def <span class="ident">validate</span></span>(<span>self, source: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf "validate" operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>configuration source to validate; typically one of running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def validate(self, source: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf &#34;validate&#34; operation

    Args:
        source: configuration source to validate; typically one of running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_validate(source=source)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response.record_response(raw_response)
    return response</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli_netconf.driver.base_driver.NetconfBaseDriver" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver">NetconfBaseDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseDriver.client_capabilities" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver.client_capabilities">client_capabilities</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseDriver.netconf_version" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver.netconf_version">netconf_version</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseDriver.server_capabilities" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver.server_capabilities">server_capabilities</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape"><code class="flex name class">
<span>class <span class="ident">AsyncNetconfScrape</span></span>
<span>(</span><span>host: str, port: int = 830, strip_namespaces: bool = False, strict_datastores: bool = False, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: float = 15.0, timeout_transport: float = 30.0, timeout_ops: float = 30.0, comms_prompt_pattern: str = &#x27;^[a-z0-9.\\-@()/:]{1,48}[#&gt;$]\\s*$&#x27;, comms_return_char: str = '\n', comms_ansi: bool = False, ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Union[Callable[..., Any], NoneType] = None, on_open: Union[Callable[..., Any], NoneType] = None, on_close: Union[Callable[..., Any], NoneType] = None, transport: str = 'system', transport_options: Union[Dict[str, Any], NoneType] = None, channel_log: Union[str, bool] = False, channel_lock: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>BaseDriver Object</p>
<p>BaseDriver is the root for all Scrapli driver classes. The synchronous and asyncio driver
base driver classes can be used to provide a semi-pexpect like experience over top of
whatever transport a user prefers. Generally, however, the base driver classes should not be
used directly. It is best to use the GenericDriver (or AsyncGenericDriver) or NetworkDriver
(or AsyncNetworkDriver) sub-classes of the base drivers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_private_key</code></strong></dt>
<dd>path to private key for authentication</dd>
<dt><strong><code>auth_private_key_passphrase</code></strong></dt>
<dd>passphrase for decrypting ssh key if necessary</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>strict host checking or not</dd>
<dt><strong><code>auth_bypass</code></strong></dt>
<dd>bypass "in channel" authentication &ndash; only supported with telnet,
asynctelnet, and system transport plugins</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket/initial connection in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for ssh channel operations</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows
for highly reliably matching for prompts however we do NOT strip trailing whitespace
for each line, so be sure to add '\s?' or similar if your device needs that. This
should be mostly sorted for you if using network drivers (i.e. <code>IOSXEDriver</code>).
Lastly, the case insensitive is just a convenience factor so i can be lazy.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>character to use to send returns to host</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output, generally the default
value of False should be fine</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file, True to use default ssh config file
or False to ignore default ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file, True to use default known
file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</dd>
<dt><strong><code>on_init</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed as the last step of object instantiation &ndash; its purpose is
primarily to provide a mechanism for scrapli community platforms to have an easy way
to modify initialization arguments/object attributes without needing to create a
class that extends the driver, instead allowing the community platforms to simply
build from the GenericDriver or NetworkDriver classes, and pass this callable to do
things such as appending to a username (looking at you RouterOS!!). Note that this
is <em>always</em> a synchronous function (even for asyncio drivers)!</dd>
<dt><strong><code>on_open</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately after authentication is completed. Common use
cases for this callable would be to disable paging or accept any kind of banner
message that prompts a user upon connection</dd>
<dt><strong><code>on_close</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately prior to closing the underlying transport.
Common use cases for this callable would be to save configurations prior to exiting,
or to logout properly to free up vtys or similar</dd>
<dt><strong><code>transport</code></strong></dt>
<dd>name of the transport plugin to use for the actual telnet/ssh/netconf
connection. Available "core" transports are:
- system
- telnet
- asynctelnet
- ssh2
- paramiko
- asyncssh
Please see relevant transport plugin section for details. Additionally third party
transport plugins may be available.</dd>
<dt><strong><code>transport_options</code></strong></dt>
<dd>dictionary of options to pass to selected transport class; see
docs for given transport class for details of what to pass here</dd>
<dt><strong><code>channel_lock</code></strong></dt>
<dd>True/False to lock the channel (threading.Lock/asyncio.Lock) during
any channel operations, defaults to False</dd>
<dt><strong><code>channel_log</code></strong></dt>
<dd>True/False or a string path to a file of where to write out channel logs &ndash;
these are not "logs" in the normal logging module sense, but only the output that is
read from the channel. In other words, the output of the channel log should look
similar to what you would see as a human connecting to a device</dd>
<dt><strong><code>logging_uid</code></strong></dt>
<dd>unique identifier (string) to associate to log messages; useful if you have
multiple connections to the same device (i.e. one console, one ssh, or one to each
supervisor module, etc.)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncNetconfScrape(AsyncNetconfDriver):
    warning = (
        &#34;`NetconfScrape` has been renamed `NetconfDriver`, `NetconfScrape` will be deprecated in &#34;
        &#34;future releases!&#34;
    )

    def __init_subclass__(cls):
        &#34;&#34;&#34;Deprecate AsyncNetconfScrape&#34;&#34;&#34;
        warn(cls.warning, DeprecationWarning, 2)

    def __new__(cls, *args, **kwargs):
        warn(cls.warning, DeprecationWarning, 2)
        return AsyncNetconfDriver(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver">AsyncNetconfDriver</a></li>
<li>scrapli.driver.base.async_driver.AsyncDriver</li>
<li><a title="scrapli_netconf.driver.base_driver.NetconfBaseDriver" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver">NetconfBaseDriver</a></li>
<li>scrapli.driver.base.base_driver.BaseDriver</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.host"><code class="name">var <span class="ident">host</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.readable_datastores"><code class="name">var <span class="ident">readable_datastores</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.strict_datastores"><code class="name">var <span class="ident">strict_datastores</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.strip_namespaces"><code class="name">var <span class="ident">strip_namespaces</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.warning"><code class="name">var <span class="ident">warning</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.writeable_datastores"><code class="name">var <span class="ident">writeable_datastores</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver">AsyncNetconfDriver</a></b></code>:
<ul class="hlist">
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.client_capabilities" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver.client_capabilities">client_capabilities</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.commit" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.commit">commit</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.delete_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.delete_config">delete_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.discard" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.discard">discard</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.edit_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.edit_config">edit_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get">get</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get_config">get_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.lock" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.lock">lock</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.netconf_version" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver.netconf_version">netconf_version</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.open" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.open">open</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.rpc" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.rpc">rpc</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.server_capabilities" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfBaseDriver.server_capabilities">server_capabilities</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.unlock" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.unlock">unlock</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.validate" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.validate">validate</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_netconf.driver" href="index.html">scrapli_netconf.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver">AsyncNetconfDriver</a></code></h4>
<ul class="">
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.commit" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.commit">commit</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.delete_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.delete_config">delete_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.discard" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.discard">discard</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.edit_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.edit_config">edit_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get">get</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.get_config">get_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.host" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.host">host</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.lock" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.lock">lock</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.open" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.open">open</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.readable_datastores" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.readable_datastores">readable_datastores</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.rpc" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.rpc">rpc</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.strict_datastores" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.strict_datastores">strict_datastores</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.strip_namespaces" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.strip_namespaces">strip_namespaces</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.unlock" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.unlock">unlock</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.validate" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.validate">validate</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfDriver.writeable_datastores" href="#scrapli_netconf.driver.async_driver.AsyncNetconfDriver.writeable_datastores">writeable_datastores</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape">AsyncNetconfScrape</a></code></h4>
<ul class="">
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.host" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.host">host</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.readable_datastores" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.readable_datastores">readable_datastores</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.strict_datastores" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.strict_datastores">strict_datastores</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.strip_namespaces" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.strip_namespaces">strip_namespaces</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.warning" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.warning">warning</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.writeable_datastores" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.writeable_datastores">writeable_datastores</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>