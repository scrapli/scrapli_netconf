<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>scrapli_netconf.driver.async_driver API documentation</title>
<meta name="description" content="scrapli_netconf.driver.driver" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_netconf.driver.async_driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli_netconf.driver.driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_netconf.driver.driver&#34;&#34;&#34;
from typing import Any, List, Optional, Union

from scrapli import AsyncScrape
from scrapli.exceptions import TransportPluginError
from scrapli_netconf.channel.async_channel import AsyncNetconfChannel
from scrapli_netconf.constants import NetconfVersion
from scrapli_netconf.driver.base_driver import NetconfScrapeBase
from scrapli_netconf.response import NetconfResponse
from scrapli_netconf.transport.asyncssh_ import NetconfAsyncSSHTransport


class AsyncNetconfScrape(AsyncScrape, NetconfScrapeBase):
    def __init__(
        self,
        port: int = 830,
        strip_namespaces: bool = True,
        strict_datastores: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(port=port, **kwargs)

        if self._transport != &#34;asyncssh&#34;:
            msg = &#34;`AsyncNetconfScrape` is only supported using the `asyncssh` transport plugin&#34;
            self.logger.exception(msg)
            raise TransportPluginError(msg)

        self.transport_class = NetconfAsyncSSHTransport
        self.transport = NetconfAsyncSSHTransport(**self.transport_args)  # type: ignore
        self.channel = AsyncNetconfChannel(self.transport, **self.channel_args)

        self.strip_namespaces = strip_namespaces
        self.strict_datastores = strict_datastores
        self.server_capabilities: List[str] = []
        self.readable_datastores: List[str] = []
        self.writeable_datastores: List[str] = []
        self.netconf_version = NetconfVersion.VERSION_1_0
        self.message_id = 101

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open netconf connection to server

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        login_bytes = await self.transport.open_netconf()
        raw_server_capabilities = await (
            self.channel._get_server_capabilities(login_bytes=login_bytes)  # pylint: disable=W0212
        )

        client_capabilities = self._process_open(raw_server_capabilities=raw_server_capabilities)

        await self.channel._send_client_capabilities(  # pylint: disable=W0212
            client_capabilities=client_capabilities, capabilities_version=self.netconf_version
        )
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get operation

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get(filter_=filter_, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)

        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_edit_config(config=config, target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf commit config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_commit()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf discard config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_discard()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf lock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_lock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf unlock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_unlock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;rpc&#34; operation; typically only used with juniper devices

        You can also use this to build send your own payload in a more manual fashion

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_rpc(filter_=filter_)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape"><code class="flex name class">
<span>class <span class="ident">AsyncNetconfScrape</span></span>
<span>(</span><span>port: int = 830, strip_namespaces: bool = True, strict_datastores: bool = False, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>AsyncScrape Object</p>
<p>AsyncScrape is the base class for AsyncNetworkDriver, and subsequent async platform specific
drivers (i.e. AsyncIOSXEDriver). AsyncScrape can be used on its own and offers a
semi-pexpect like experience in that it doesn't know or care about privilege levels,
platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments to pass to <code>ScrapeBase</code> &ndash; see <code>ScrapeBase</code> for available args</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncNetconfScrape(AsyncScrape, NetconfScrapeBase):
    def __init__(
        self,
        port: int = 830,
        strip_namespaces: bool = True,
        strict_datastores: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(port=port, **kwargs)

        if self._transport != &#34;asyncssh&#34;:
            msg = &#34;`AsyncNetconfScrape` is only supported using the `asyncssh` transport plugin&#34;
            self.logger.exception(msg)
            raise TransportPluginError(msg)

        self.transport_class = NetconfAsyncSSHTransport
        self.transport = NetconfAsyncSSHTransport(**self.transport_args)  # type: ignore
        self.channel = AsyncNetconfChannel(self.transport, **self.channel_args)

        self.strip_namespaces = strip_namespaces
        self.strict_datastores = strict_datastores
        self.server_capabilities: List[str] = []
        self.readable_datastores: List[str] = []
        self.writeable_datastores: List[str] = []
        self.netconf_version = NetconfVersion.VERSION_1_0
        self.message_id = 101

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open netconf connection to server

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        login_bytes = await self.transport.open_netconf()
        raw_server_capabilities = await (
            self.channel._get_server_capabilities(login_bytes=login_bytes)  # pylint: disable=W0212
        )

        client_capabilities = self._process_open(raw_server_capabilities=raw_server_capabilities)

        await self.channel._send_client_capabilities(  # pylint: disable=W0212
            client_capabilities=client_capabilities, capabilities_version=self.netconf_version
        )
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get operation

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get(filter_=filter_, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)

        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_edit_config(config=config, target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf commit config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_commit()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf discard config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_discard()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf lock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_lock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf unlock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_unlock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;rpc&#34; operation; typically only used with juniper devices

        You can also use this to build send your own payload in a more manual fashion

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_rpc(filter_=filter_)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.driver.async_driver.AsyncScrape</li>
<li><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfScrapeBase">NetconfScrapeBase</a></li>
<li>scrapli.driver.base_driver.ScrapeBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.commit"><code class="name flex">
<span>async def <span class="ident">commit</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf commit config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def commit(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf commit config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_commit()
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.discard"><code class="name flex">
<span>async def <span class="ident">discard</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf discard config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def discard(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf discard config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_discard()
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.edit_config"><code class="name flex">
<span>async def <span class="ident">edit_config</span></span>(<span>self, config: str, target: str = 'running') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>configuration to send to device</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        config: configuration to send to device
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_edit_config(config=config, target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.get"><code class="name flex">
<span>async def <span class="ident">get</span></span>(<span>self, filter_: str, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>string filter to apply to the get</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get operation

    Args:
        filter_: string filter to apply to the get
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get(filter_=filter_, filter_type=filter_type)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.get_config"><code class="name flex">
<span>async def <span class="ident">get_config</span></span>(<span>self, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>configuration source to get; typically one of running|startup|candidate</dd>
<dt><strong><code>filters</code></strong></dt>
<dd>string or list of strings of filters to apply to configuration</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_config(
    self,
    source: str = &#34;running&#34;,
    filters: Optional[Union[str, List[str]]] = None,
    filter_type: str = &#34;subtree&#34;,
) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        source: configuration source to get; typically one of running|startup|candidate
        filters: string or list of strings of filters to apply to configuration
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
    raw_response = await self.channel.send_input_netconf(response.channel_input)

    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.lock"><code class="name flex">
<span>async def <span class="ident">lock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf lock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def lock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf lock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_lock(target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open netconf connection to server</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open netconf connection to server

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    login_bytes = await self.transport.open_netconf()
    raw_server_capabilities = await (
        self.channel._get_server_capabilities(login_bytes=login_bytes)  # pylint: disable=W0212
    )

    client_capabilities = self._process_open(raw_server_capabilities=raw_server_capabilities)

    await self.channel._send_client_capabilities(  # pylint: disable=W0212
        client_capabilities=client_capabilities, capabilities_version=self.netconf_version
    )
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.rpc"><code class="name flex">
<span>async def <span class="ident">rpc</span></span>(<span>self, filter_: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf "rpc" operation; typically only used with juniper devices</p>
<p>You can also use this to build send your own payload in a more manual fashion</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>filter/rpc to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def rpc(self, filter_: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf &#34;rpc&#34; operation; typically only used with juniper devices

    You can also use this to build send your own payload in a more manual fashion

    Args:
        filter_: filter/rpc to execute

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_rpc(filter_=filter_)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.unlock"><code class="name flex">
<span>async def <span class="ident">unlock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf unlock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unlock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf unlock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_unlock(target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_netconf.driver" href="index.html">scrapli_netconf.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape">AsyncNetconfScrape</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.commit" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.commit">commit</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.discard" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.discard">discard</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.edit_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.edit_config">edit_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.get" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.get">get</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.get_config" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.get_config">get_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.lock" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.lock">lock</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.open" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.open">open</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.rpc" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.rpc">rpc</a></code></li>
<li><code><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape.unlock" href="#scrapli_netconf.driver.async_driver.AsyncNetconfScrape.unlock">unlock</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>