<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>scrapli_netconf.driver.base_driver API documentation</title>
<meta name="description" content="scrapli_netconf.driver.base_driver" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_netconf.driver.base_driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli_netconf.driver.base_driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_netconf.driver.base_driver&#34;&#34;&#34;
import re
import warnings
from enum import Enum
from typing import List, Optional, Union

from lxml import etree
from lxml.etree import Element

from scrapli.driver.base_driver import ScrapeBase
from scrapli_netconf.constants import NetconfVersion
from scrapli_netconf.exceptions import CapabilityNotSupported, CouldNotExchangeCapabilities
from scrapli_netconf.response import NetconfResponse


class NetconfClientCapabilities(Enum):
    CAPABILITIES_1_0 = &#34;&#34;&#34;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
    &lt;hello xmlns=&#34;urn:ietf:params:xml:ns:netconf:base:1.0&#34;&gt;
        &lt;capabilities&gt;
            &lt;capability&gt;urn:ietf:params:netconf:base:1.0&lt;/capability&gt;
        &lt;/capabilities&gt;
&lt;/hello&gt;]]&gt;]]&gt;&#34;&#34;&#34;
    CAPABILITIES_1_1 = &#34;&#34;&#34;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
    &lt;hello xmlns=&#34;urn:ietf:params:xml:ns:netconf:base:1.0&#34;&gt;
        &lt;capabilities&gt;
            &lt;capability&gt;urn:ietf:params:netconf:base:1.1&lt;/capability&gt;
        &lt;/capabilities&gt;
&lt;/hello&gt;]]&gt;]]&gt;&#34;&#34;&#34;


class NetconfBaseOperations(Enum):
    FILTER_SUBTREE = &#34;&lt;filter type=&#39;{filter_type}&#39;&gt;&lt;/filter&gt;&#34;
    FILTER_XPATH = &#34;&lt;filter type=&#39;{filter_type}&#39; select=&#39;{xpath}&#39;&gt;&lt;/filter&gt;&#34;
    GET = &#34;&lt;get&gt;&lt;/get&gt;&#34;
    GET_CONFIG = &#34;&lt;get-config&gt;&lt;source&gt;&lt;{source}/&gt;&lt;/source&gt;&lt;/get-config&gt;&#34;
    EDIT_CONFIG = &#34;&lt;edit-config&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/edit-config&gt;&#34;
    DELETE_CONFIG = &#34;&lt;delete-config&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/delete-config&gt;&#34;
    COMMIT = &#34;&lt;commit/&gt;&#34;
    DISCARD = &#34;&lt;discard-changes/&gt;&#34;
    LOCK = &#34;&lt;lock&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/lock&gt;&#34;
    UNLOCK = &#34;&lt;unlock&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/unlock&gt;&#34;
    RPC = &#34;&lt;rpc xmlns=&#39;urn:ietf:params:xml:ns:netconf:base:1.0&#39; message-id=&#39;{message_id}&#39;&gt;&lt;/rpc&gt;&#34;
    VALIDATE = &#34;&lt;validate&gt;&lt;source&gt;&lt;{source}/&gt;&lt;/source&gt;&lt;/validate&gt;&#34;


class NetconfScrapeBase(ScrapeBase):
    server_capabilities: List[str]
    readable_datastores: List[str]
    writeable_datastores: List[str]
    netconf_version: NetconfVersion
    strip_namespaces: bool
    strict_datastores: bool
    message_id: int

    def _process_open(self, raw_server_capabilities: bytes) -&gt; NetconfClientCapabilities:
        &#34;&#34;&#34;
        Process received capabilities; return client capabilities

        Args:
            raw_server_capabilities: raw bytes containing server capabilities

        Returns:
            NetconfClientCapabilities: NetconfClientCapabilities enum of appropriate type

        Raises:
            N/A

        &#34;&#34;&#34;
        self._parse_server_capabilities(raw_server_capabilities=raw_server_capabilities)

        client_capabilities = NetconfClientCapabilities.CAPABILITIES_1_0
        if &#34;urn:ietf:params:netconf:base:1.1&#34; in self.server_capabilities:
            client_capabilities = NetconfClientCapabilities.CAPABILITIES_1_1
            self.netconf_version = NetconfVersion.VERSION_1_1

        return client_capabilities

    def _parse_server_capabilities(self, raw_server_capabilities: bytes) -&gt; None:
        &#34;&#34;&#34;
        Parse netconf server capabilities

        Args:
            raw_server_capabilities: raw bytes containing server capabilities

        Returns:
            N/A  # noqa: DAR202

        Raises:
            CouldNotExchangeCapabilities: if server capabilities cannot be parsed

        &#34;&#34;&#34;
        filtered_raw_server_capabilities = re.search(
            pattern=rb&#34;(&lt;hello.*&lt;\/hello&gt;)&#34;, string=raw_server_capabilities, flags=re.I | re.S
        )
        if filtered_raw_server_capabilities is None:
            msg = f&#34;Failed to parse server capabilities from host {self._host}&#34;
            raise CouldNotExchangeCapabilities(msg)
        server_capabilities_xml = etree.fromstring(filtered_raw_server_capabilities.groups()[0])
        for elem in server_capabilities_xml.iter():
            if &#34;capability&#34; not in elem.tag:
                continue
            self.server_capabilities.append(elem.text.strip())
        self._build_readable_datastores()
        self._build_writeable_datastores()
        self.logger.info(f&#34;Server capabilities received and parsed: {self.server_capabilities}&#34;)

    def _build_readable_datastores(self) -&gt; None:
        &#34;&#34;&#34;
        Build a list of readable datastores based on server&#39;s advertised capabilities

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.readable_datastores = []
        self.readable_datastores.append(&#34;running&#34;)
        if &#34;urn:ietf:params:netconf:capability:candidate:1.0&#34; in self.server_capabilities:
            self.readable_datastores.append(&#34;candidate&#34;)
        if &#34;urn:ietf:params:netconf:capability:startup:1.0&#34; in self.server_capabilities:
            self.readable_datastores.append(&#34;startup&#34;)

    def _build_writeable_datastores(self) -&gt; None:
        &#34;&#34;&#34;
        Build a list of writeable/editable datastores based on server&#39;s advertised capabilities

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.writeable_datastores = []
        if &#34;urn:ietf:params:netconf:capability:writeable-running:1.0&#34; in self.server_capabilities:
            self.writeable_datastores.append(&#34;running&#34;)
        if &#34;urn:ietf:params:netconf:capability:writable-running:1.0&#34; in self.server_capabilities:
            # NOTE: iosxe shows &#34;writable&#34; (as of 2020.07.01) despite RFC being &#34;writeable&#34;
            self.writeable_datastores.append(&#34;running&#34;)
        if &#34;urn:ietf:params:netconf:capability:candidate:1.0&#34; in self.server_capabilities:
            self.writeable_datastores.append(&#34;candidate&#34;)
        if &#34;urn:ietf:params:netconf:capability:startup:1.0&#34; in self.server_capabilities:
            self.writeable_datastores.append(&#34;startup&#34;)

    def _validate_get_config_target(self, source: str) -&gt; None:
        &#34;&#34;&#34;
        Validate get-config source is acceptable

        Args:
            source: configuration source to get; typically one of running|startup|candidate

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if an invalid source was selected and strict_datastores is True

        &#34;&#34;&#34;
        if source not in self.readable_datastores:
            msg = f&#34;`source` should be one of {self.readable_datastores}, got `{source}`&#34;
            self.logger.warning(msg)
            if self.strict_datastores is True:
                raise ValueError(msg)
            warnings.warn(msg)

    def _validate_edit_config_target(self, target: str) -&gt; None:
        &#34;&#34;&#34;
        Validate edit-config/lock/unlock target is acceptable

        Args:
            target: configuration source to edit/lock; typically one of running|startup|candidate

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if an invalid source was selected

        &#34;&#34;&#34;
        if target not in self.writeable_datastores:
            msg = f&#34;`target` should be one of {self.writeable_datastores}, got `{target}`&#34;
            self.logger.warning(msg)
            if self.strict_datastores is True:
                raise ValueError(msg)
            warnings.warn(msg)

    def _validate_delete_config_target(self, target: str) -&gt; None:
        &#34;&#34;&#34;
        Validate delete-config/lock/unlock target is acceptable

        Args:
            target: configuration source to delete; typically one of startup|candidate

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if an invalid target was selected

        &#34;&#34;&#34;
        if target == &#34;running&#34; or target not in self.writeable_datastores:
            msg = f&#34;`target` should be one of {self.writeable_datastores}, got `{target}`&#34;
            if target == &#34;running&#34;:
                msg = &#34;delete-config `target` may not be `running`&#34;
            self.logger.warning(msg)
            if self.strict_datastores is True:
                raise ValueError(msg)
            warnings.warn(msg)

    def _build_base_elem(self) -&gt; Element:
        &#34;&#34;&#34;
        Create base element for netconf operations

        Args:
            N/A

        Returns:
            Element: lxml base element to use for netconf operation

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(f&#34;Building base element for message id {self.message_id}&#34;)
        base_xml_str = NetconfBaseOperations.RPC.value.format(message_id=self.message_id)
        self.message_id += 1
        base_elem = etree.fromstring(text=base_xml_str)
        return base_elem

    def _build_filters(self, filters: List[str], filter_type: str = &#34;subtree&#34;) -&gt; Element:
        &#34;&#34;&#34;
        Create filter element for a given rpc

        Args:
            filters: list of strings of filters to build into a filter element
            filter_type: type of filter; subtree|xpath

        Returns:
            Element: lxml filter element to use for netconf operation

        Raises:
            CapabilityNotSupported: if xpath selected and not supported on server
            ValueError: if filter_type is not one of subtree|xpath

        &#34;&#34;&#34;
        if filter_type == &#34;subtree&#34;:
            xml_filter_elem = etree.fromstring(
                NetconfBaseOperations.FILTER_SUBTREE.value.format(filter_type=filter_type)
            )
            for filter_ in filters:
                # &#34;validate&#34; subtree filter by forcing it into xml
                xml_filter_element = etree.fromstring(filter_)
                # insert the subtree filter into the parent filter element
                xml_filter_elem.insert(1, xml_filter_element)
        elif filter_type == &#34;xpath&#34;:
            if &#34;urn:ietf:params:netconf:capability:xpath:1.0&#34; not in self.server_capabilities:
                msg = &#34;xpath filter requested, but is not supported by the server&#34;
                self.logger.exception(msg)
                raise CapabilityNotSupported(msg)
            # assuming for now that there will only ever be a single xpath string/filter... this may
            # end up being a shitty assumption!
            filter_ = filters[0]
            xml_filter_elem = etree.fromstring(
                NetconfBaseOperations.FILTER_XPATH.value.format(
                    filter_type=filter_type, xpath=filter_
                )
            )
        else:
            raise ValueError(f&#34;`filter_type` should be one of subtree|xpath, got `{filter_type}`&#34;)
        return xml_filter_elem

    def _pre_get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;get&#34; tasks for consistency between sync/async versions

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Building payload for `get` operation. filter_type: {filter_type}, filter_: {filter_}&#34;
        )

        # build base request and insert the get element
        xml_request = self._build_base_elem()
        xml_get_element = etree.fromstring(NetconfBaseOperations.GET.value)
        xml_request.insert(0, xml_get_element)

        xml_filter_elem = self._build_filters(filters=[filter_], filter_type=filter_type)

        # insert filter element into parent get element
        get_element = xml_request.find(&#34;get&#34;)
        get_element.insert(0, xml_filter_elem)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(f&#34;Built payload for `get` operation. Payload: {channel_input.decode()}&#34;)
        return response

    def _pre_get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;get_config&#34; tasks for consistency between sync/async versions

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Building payload for `get-config` operation. source: {source}, filter_type: &#34;
            f&#34;{filter_type}, filters: {filters}&#34;
        )
        self._validate_get_config_target(source=source)

        # build base request and insert the get-config element
        xml_request = self._build_base_elem()
        xml_get_config_element = etree.fromstring(
            NetconfBaseOperations.GET_CONFIG.value.format(source=source)
        )
        xml_request.insert(0, xml_get_config_element)

        if filters is not None:
            if isinstance(filters, str):
                filters = [filters]
            xml_filter_elem = self._build_filters(filters=filters, filter_type=filter_type)
            # insert filter element into parent get element
            get_element = xml_request.find(&#34;get-config&#34;)
            # insert *after* source, otherwise juniper seems to gripe, maybe/probably others as well
            get_element.insert(1, xml_filter_elem)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `get-config` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_edit_config(
        self, config: Union[str, List[str]], target: str = &#34;running&#34;
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;edit_config&#34; tasks for consistency between sync/async versions

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Building payload for `get-config` operation. target: {target}, config: {config}&#34;
        )
        self._validate_edit_config_target(target=target)

        # build config first to ensure valid xml
        xml_config = etree.fromstring(config)

        # build base request and insert the edit-config element
        xml_request = self._build_base_elem()
        xml_edit_config_element = etree.fromstring(
            NetconfBaseOperations.EDIT_CONFIG.value.format(target=target)
        )
        xml_request.insert(0, xml_edit_config_element)

        # insert parent filter element to first position so that target stays first just for nice
        # output/readability
        edit_config_element = xml_request.find(&#34;edit-config&#34;)
        edit_config_element.insert(1, xml_config)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `edit-config` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_delete_config(self, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;edit_config&#34; tasks for consistency between sync/async versions

        Args:
            target: configuration source to target; startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(f&#34;Building payload for `delete-config` operation. target: {target}&#34;)
        self._validate_delete_config_target(target=target)

        xml_request = self._build_base_elem()
        xml_validate_element = etree.fromstring(
            NetconfBaseOperations.DELETE_CONFIG.value.format(target=target)
        )
        xml_request.insert(0, xml_validate_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `delete-config` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;commit&#34; tasks for consistency between sync/async versions

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `commit` operation&#34;)
        xml_request = self._build_base_elem()
        xml_commit_element = etree.fromstring(NetconfBaseOperations.COMMIT.value)
        xml_request.insert(0, xml_commit_element)
        channel_input = etree.tostring(xml_request)

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `commit` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;discard&#34; tasks for consistency between sync/async versions

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `discard` operation.&#34;)
        xml_request = self._build_base_elem()
        xml_commit_element = etree.fromstring(NetconfBaseOperations.DISCARD.value)
        xml_request.insert(0, xml_commit_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `discard` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;lock&#34; tasks for consistency between sync/async versions

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `lock` operation.&#34;)
        self._validate_edit_config_target(target=target)

        xml_request = self._build_base_elem()
        xml_lock_element = etree.fromstring(NetconfBaseOperations.LOCK.value.format(target=target))
        xml_request.insert(0, xml_lock_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(f&#34;Built payload for `lock` operation. Payload: {channel_input.decode()}&#34;)
        return response

    def _pre_unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;unlock&#34; tasks for consistency between sync/async versions

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `unlock` operation.&#34;)
        self._validate_edit_config_target(target=target)

        xml_request = self._build_base_elem()
        xml_lock_element = etree.fromstring(
            NetconfBaseOperations.UNLOCK.value.format(target=target)
        )
        xml_request.insert(0, xml_lock_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `unlock` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;rpc&#34; tasks for consistency between sync/async versions

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `rpc` operation.&#34;)
        xml_request = self._build_base_elem()

        # build filter element
        xml_filter_elem = etree.fromstring(filter_)

        # insert filter element
        xml_request.insert(0, xml_filter_elem)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(f&#34;Built payload for `rpc` operation. Payload: {channel_input.decode()}&#34;)
        return response

    def _pre_validate(self, source: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;validate&#34; tasks for consistency between sync/async versions

        Args:
            source: configuration source to validate; typically one of running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            CapabilityNotSupported: if `validate` ca

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `validate` operation.&#34;)

        if not any(
            cap in self.server_capabilities
            for cap in (
                &#34;urn:ietf:params:netconf:capability:validate:1.0&#34;,
                &#34;urn:ietf:params:netconf:capability:validate:1.1&#34;,
            )
        ):
            msg = &#34;validate requested, but is not supported by the server&#34;
            self.logger.exception(msg)
            raise CapabilityNotSupported(msg)

        self._validate_edit_config_target(target=source)

        xml_request = self._build_base_elem()
        xml_validate_element = etree.fromstring(
            NetconfBaseOperations.VALIDATE.value.format(source=source)
        )
        xml_request.insert(0, xml_validate_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `validate` operation. Payload: {channel_input.decode()}&#34;
        )
        return response</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations"><code class="flex name class">
<span>class <span class="ident">NetconfBaseOperations</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetconfBaseOperations(Enum):
    FILTER_SUBTREE = &#34;&lt;filter type=&#39;{filter_type}&#39;&gt;&lt;/filter&gt;&#34;
    FILTER_XPATH = &#34;&lt;filter type=&#39;{filter_type}&#39; select=&#39;{xpath}&#39;&gt;&lt;/filter&gt;&#34;
    GET = &#34;&lt;get&gt;&lt;/get&gt;&#34;
    GET_CONFIG = &#34;&lt;get-config&gt;&lt;source&gt;&lt;{source}/&gt;&lt;/source&gt;&lt;/get-config&gt;&#34;
    EDIT_CONFIG = &#34;&lt;edit-config&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/edit-config&gt;&#34;
    DELETE_CONFIG = &#34;&lt;delete-config&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/delete-config&gt;&#34;
    COMMIT = &#34;&lt;commit/&gt;&#34;
    DISCARD = &#34;&lt;discard-changes/&gt;&#34;
    LOCK = &#34;&lt;lock&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/lock&gt;&#34;
    UNLOCK = &#34;&lt;unlock&gt;&lt;target&gt;&lt;{target}/&gt;&lt;/target&gt;&lt;/unlock&gt;&#34;
    RPC = &#34;&lt;rpc xmlns=&#39;urn:ietf:params:xml:ns:netconf:base:1.0&#39; message-id=&#39;{message_id}&#39;&gt;&lt;/rpc&gt;&#34;
    VALIDATE = &#34;&lt;validate&gt;&lt;source&gt;&lt;{source}/&gt;&lt;/source&gt;&lt;/validate&gt;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.COMMIT"><code class="name">var <span class="ident">COMMIT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.DELETE_CONFIG"><code class="name">var <span class="ident">DELETE_CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.DISCARD"><code class="name">var <span class="ident">DISCARD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.EDIT_CONFIG"><code class="name">var <span class="ident">EDIT_CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.FILTER_SUBTREE"><code class="name">var <span class="ident">FILTER_SUBTREE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.FILTER_XPATH"><code class="name">var <span class="ident">FILTER_XPATH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.GET"><code class="name">var <span class="ident">GET</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.GET_CONFIG"><code class="name">var <span class="ident">GET_CONFIG</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.LOCK"><code class="name">var <span class="ident">LOCK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.RPC"><code class="name">var <span class="ident">RPC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.UNLOCK"><code class="name">var <span class="ident">UNLOCK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfBaseOperations.VALIDATE"><code class="name">var <span class="ident">VALIDATE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfClientCapabilities"><code class="flex name class">
<span>class <span class="ident">NetconfClientCapabilities</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetconfClientCapabilities(Enum):
    CAPABILITIES_1_0 = &#34;&#34;&#34;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
    &lt;hello xmlns=&#34;urn:ietf:params:xml:ns:netconf:base:1.0&#34;&gt;
        &lt;capabilities&gt;
            &lt;capability&gt;urn:ietf:params:netconf:base:1.0&lt;/capability&gt;
        &lt;/capabilities&gt;
&lt;/hello&gt;]]&gt;]]&gt;&#34;&#34;&#34;
    CAPABILITIES_1_1 = &#34;&#34;&#34;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;
    &lt;hello xmlns=&#34;urn:ietf:params:xml:ns:netconf:base:1.0&#34;&gt;
        &lt;capabilities&gt;
            &lt;capability&gt;urn:ietf:params:netconf:base:1.1&lt;/capability&gt;
        &lt;/capabilities&gt;
&lt;/hello&gt;]]&gt;]]&gt;&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli_netconf.driver.base_driver.NetconfClientCapabilities.CAPABILITIES_1_0"><code class="name">var <span class="ident">CAPABILITIES_1_0</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfClientCapabilities.CAPABILITIES_1_1"><code class="name">var <span class="ident">CAPABILITIES_1_1</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase"><code class="flex name class">
<span>class <span class="ident">NetconfScrapeBase</span></span>
<span>(</span><span>host: str = '', port: int = 22, auth_username: str = '', auth_password: str = '', auth_private_key: str = '', auth_private_key_passphrase: str = '', auth_strict_key: bool = True, auth_bypass: bool = False, timeout_socket: int = 5, timeout_transport: int = 10, timeout_ops: float = 30, timeout_exit: bool = True, keepalive: bool = False, keepalive_interval: int = 30, keepalive_type: str = 'network', keepalive_pattern: str = '\x05', comms_prompt_pattern: str = &#x27;^[a-z0-9.\\-@()/:]{1,48}[#&gt;$]\\s*$&#x27;, comms_return_char: str = '\n', comms_ansi: bool = False, ssh_config_file: Union[str, bool] = False, ssh_known_hosts_file: Union[str, bool] = False, on_init: Union[Callable[..., Any], NoneType] = None, on_open: Union[Callable[..., Any], NoneType] = None, on_close: Union[Callable[..., Any], NoneType] = None, transport: str = 'system', transport_options: Union[Dict[str, Any], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Scrape Object</p>
<p>Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
that it doesn't know or care about privilege levels, platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_private_key</code></strong></dt>
<dd>path to private key for authentication</dd>
<dt><strong><code>auth_private_key_passphrase</code></strong></dt>
<dd>passphrase for decrypting ssh key if necessary</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>strict host checking or not &ndash; applicable for system ssh driver only</dd>
<dt><strong><code>auth_bypass</code></strong></dt>
<dd>bypass ssh key or password auth for devices without authentication, or that
have auth prompts after ssh session establishment. Currently only supported on
system transport; ignored on other transports</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh|telnet transport in seconds</dd>
<dt><strong><code>timeout_ops</code></strong></dt>
<dd>timeout for ssh channel operations</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' attempts to use whatever 'standard'
keepalive mechanisms are available in the selected transport mechanism. Check the
transport documentation for details on what is supported and/or how it is
implemented for any given transport driver</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'\005' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>comms_prompt_pattern</code></strong></dt>
<dd>raw string regex pattern &ndash; preferably use <code>^</code> and <code>$</code> anchors!
this is the single most important attribute here! if this does not match a prompt,
scrapli will not work!
IMPORTANT: regex search uses multi-line + case insensitive flags. multi-line allows
for highly reliably matching for prompts however we do NOT strip trailing whitespace
for each line, so be sure to add '\s?' or similar if your device needs that. This
should be mostly sorted for you if using network drivers (i.e. <code>IOSXEDriver</code>).
Lastly, the case insensitive is just a convenience factor so i can be lazy.</dd>
<dt><strong><code>comms_return_char</code></strong></dt>
<dd>character to use to send returns to host</dd>
<dt><strong><code>comms_ansi</code></strong></dt>
<dd>True/False strip comms_ansi characters from output</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file, True to use default ssh config file
or False to ignore default ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file, True to use default known
file locations. Only applicable/needed if <code>auth_strict_key</code> is set to True</dd>
<dt><strong><code>on_init</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed as the last step of object instantiation &ndash; its purpose is
primarily to provide a mechanism for scrapli community platforms to have an easy way
to modify initialization arguments/object attributes without needing to create a
class that extends the driver, instead allowing the community platforms to simply
build from the GenericDriver or NetworkDriver classes, and pass this callable to do
things such as appending to a username (looking at you RouterOS!!). Note that this
is <em>always</em> a synchronous function (even for asyncio drivers)!</dd>
<dt><strong><code>on_open</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately after authentication is completed. Common use
cases for this callable would be to disable paging or accept any kind of banner
message that prompts a user upon connection</dd>
<dt><strong><code>on_close</code></strong></dt>
<dd>callable that accepts the class instance as its only argument. this callable,
if provided, is executed immediately prior to closing the underlying transport.
Common use cases for this callable would be to save configurations prior to exiting,
or to logout properly to free up vtys or similar.</dd>
<dt><strong><code>transport</code></strong></dt>
<dd>system|telnet or a plugin &ndash; type of transport to use for connection
system uses system available ssh (/usr/bin/ssh)
ssh2 uses ssh2-python <em>has been migrated to a plugin
paramiko uses&hellip; paramiko </em>has been migrated to a plugin
telnet uses telnetlib
choice of driver depends on the features you need. in general system is easiest as
it will just 'auto-magically' use your ssh config file ('~/.ssh/config' or
'/etc/ssh/config_file'). ssh2 is very very fast as it is a thin wrapper around
libssh2 however it is slightly feature limited. paramiko is slower than ssh2, but
has more features built in (though scrapli does not expose/support them all).</dd>
<dt><strong><code>transport_options</code></strong></dt>
<dd>dictionary of options to pass to selected transport class; see
docs for given transport class for details of what to pass here</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>UnsupportedPlatform</code></dt>
<dd>if using windows with system transport</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetconfScrapeBase(ScrapeBase):
    server_capabilities: List[str]
    readable_datastores: List[str]
    writeable_datastores: List[str]
    netconf_version: NetconfVersion
    strip_namespaces: bool
    strict_datastores: bool
    message_id: int

    def _process_open(self, raw_server_capabilities: bytes) -&gt; NetconfClientCapabilities:
        &#34;&#34;&#34;
        Process received capabilities; return client capabilities

        Args:
            raw_server_capabilities: raw bytes containing server capabilities

        Returns:
            NetconfClientCapabilities: NetconfClientCapabilities enum of appropriate type

        Raises:
            N/A

        &#34;&#34;&#34;
        self._parse_server_capabilities(raw_server_capabilities=raw_server_capabilities)

        client_capabilities = NetconfClientCapabilities.CAPABILITIES_1_0
        if &#34;urn:ietf:params:netconf:base:1.1&#34; in self.server_capabilities:
            client_capabilities = NetconfClientCapabilities.CAPABILITIES_1_1
            self.netconf_version = NetconfVersion.VERSION_1_1

        return client_capabilities

    def _parse_server_capabilities(self, raw_server_capabilities: bytes) -&gt; None:
        &#34;&#34;&#34;
        Parse netconf server capabilities

        Args:
            raw_server_capabilities: raw bytes containing server capabilities

        Returns:
            N/A  # noqa: DAR202

        Raises:
            CouldNotExchangeCapabilities: if server capabilities cannot be parsed

        &#34;&#34;&#34;
        filtered_raw_server_capabilities = re.search(
            pattern=rb&#34;(&lt;hello.*&lt;\/hello&gt;)&#34;, string=raw_server_capabilities, flags=re.I | re.S
        )
        if filtered_raw_server_capabilities is None:
            msg = f&#34;Failed to parse server capabilities from host {self._host}&#34;
            raise CouldNotExchangeCapabilities(msg)
        server_capabilities_xml = etree.fromstring(filtered_raw_server_capabilities.groups()[0])
        for elem in server_capabilities_xml.iter():
            if &#34;capability&#34; not in elem.tag:
                continue
            self.server_capabilities.append(elem.text.strip())
        self._build_readable_datastores()
        self._build_writeable_datastores()
        self.logger.info(f&#34;Server capabilities received and parsed: {self.server_capabilities}&#34;)

    def _build_readable_datastores(self) -&gt; None:
        &#34;&#34;&#34;
        Build a list of readable datastores based on server&#39;s advertised capabilities

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.readable_datastores = []
        self.readable_datastores.append(&#34;running&#34;)
        if &#34;urn:ietf:params:netconf:capability:candidate:1.0&#34; in self.server_capabilities:
            self.readable_datastores.append(&#34;candidate&#34;)
        if &#34;urn:ietf:params:netconf:capability:startup:1.0&#34; in self.server_capabilities:
            self.readable_datastores.append(&#34;startup&#34;)

    def _build_writeable_datastores(self) -&gt; None:
        &#34;&#34;&#34;
        Build a list of writeable/editable datastores based on server&#39;s advertised capabilities

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.writeable_datastores = []
        if &#34;urn:ietf:params:netconf:capability:writeable-running:1.0&#34; in self.server_capabilities:
            self.writeable_datastores.append(&#34;running&#34;)
        if &#34;urn:ietf:params:netconf:capability:writable-running:1.0&#34; in self.server_capabilities:
            # NOTE: iosxe shows &#34;writable&#34; (as of 2020.07.01) despite RFC being &#34;writeable&#34;
            self.writeable_datastores.append(&#34;running&#34;)
        if &#34;urn:ietf:params:netconf:capability:candidate:1.0&#34; in self.server_capabilities:
            self.writeable_datastores.append(&#34;candidate&#34;)
        if &#34;urn:ietf:params:netconf:capability:startup:1.0&#34; in self.server_capabilities:
            self.writeable_datastores.append(&#34;startup&#34;)

    def _validate_get_config_target(self, source: str) -&gt; None:
        &#34;&#34;&#34;
        Validate get-config source is acceptable

        Args:
            source: configuration source to get; typically one of running|startup|candidate

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if an invalid source was selected and strict_datastores is True

        &#34;&#34;&#34;
        if source not in self.readable_datastores:
            msg = f&#34;`source` should be one of {self.readable_datastores}, got `{source}`&#34;
            self.logger.warning(msg)
            if self.strict_datastores is True:
                raise ValueError(msg)
            warnings.warn(msg)

    def _validate_edit_config_target(self, target: str) -&gt; None:
        &#34;&#34;&#34;
        Validate edit-config/lock/unlock target is acceptable

        Args:
            target: configuration source to edit/lock; typically one of running|startup|candidate

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if an invalid source was selected

        &#34;&#34;&#34;
        if target not in self.writeable_datastores:
            msg = f&#34;`target` should be one of {self.writeable_datastores}, got `{target}`&#34;
            self.logger.warning(msg)
            if self.strict_datastores is True:
                raise ValueError(msg)
            warnings.warn(msg)

    def _validate_delete_config_target(self, target: str) -&gt; None:
        &#34;&#34;&#34;
        Validate delete-config/lock/unlock target is acceptable

        Args:
            target: configuration source to delete; typically one of startup|candidate

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ValueError: if an invalid target was selected

        &#34;&#34;&#34;
        if target == &#34;running&#34; or target not in self.writeable_datastores:
            msg = f&#34;`target` should be one of {self.writeable_datastores}, got `{target}`&#34;
            if target == &#34;running&#34;:
                msg = &#34;delete-config `target` may not be `running`&#34;
            self.logger.warning(msg)
            if self.strict_datastores is True:
                raise ValueError(msg)
            warnings.warn(msg)

    def _build_base_elem(self) -&gt; Element:
        &#34;&#34;&#34;
        Create base element for netconf operations

        Args:
            N/A

        Returns:
            Element: lxml base element to use for netconf operation

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(f&#34;Building base element for message id {self.message_id}&#34;)
        base_xml_str = NetconfBaseOperations.RPC.value.format(message_id=self.message_id)
        self.message_id += 1
        base_elem = etree.fromstring(text=base_xml_str)
        return base_elem

    def _build_filters(self, filters: List[str], filter_type: str = &#34;subtree&#34;) -&gt; Element:
        &#34;&#34;&#34;
        Create filter element for a given rpc

        Args:
            filters: list of strings of filters to build into a filter element
            filter_type: type of filter; subtree|xpath

        Returns:
            Element: lxml filter element to use for netconf operation

        Raises:
            CapabilityNotSupported: if xpath selected and not supported on server
            ValueError: if filter_type is not one of subtree|xpath

        &#34;&#34;&#34;
        if filter_type == &#34;subtree&#34;:
            xml_filter_elem = etree.fromstring(
                NetconfBaseOperations.FILTER_SUBTREE.value.format(filter_type=filter_type)
            )
            for filter_ in filters:
                # &#34;validate&#34; subtree filter by forcing it into xml
                xml_filter_element = etree.fromstring(filter_)
                # insert the subtree filter into the parent filter element
                xml_filter_elem.insert(1, xml_filter_element)
        elif filter_type == &#34;xpath&#34;:
            if &#34;urn:ietf:params:netconf:capability:xpath:1.0&#34; not in self.server_capabilities:
                msg = &#34;xpath filter requested, but is not supported by the server&#34;
                self.logger.exception(msg)
                raise CapabilityNotSupported(msg)
            # assuming for now that there will only ever be a single xpath string/filter... this may
            # end up being a shitty assumption!
            filter_ = filters[0]
            xml_filter_elem = etree.fromstring(
                NetconfBaseOperations.FILTER_XPATH.value.format(
                    filter_type=filter_type, xpath=filter_
                )
            )
        else:
            raise ValueError(f&#34;`filter_type` should be one of subtree|xpath, got `{filter_type}`&#34;)
        return xml_filter_elem

    def _pre_get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;get&#34; tasks for consistency between sync/async versions

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Building payload for `get` operation. filter_type: {filter_type}, filter_: {filter_}&#34;
        )

        # build base request and insert the get element
        xml_request = self._build_base_elem()
        xml_get_element = etree.fromstring(NetconfBaseOperations.GET.value)
        xml_request.insert(0, xml_get_element)

        xml_filter_elem = self._build_filters(filters=[filter_], filter_type=filter_type)

        # insert filter element into parent get element
        get_element = xml_request.find(&#34;get&#34;)
        get_element.insert(0, xml_filter_elem)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(f&#34;Built payload for `get` operation. Payload: {channel_input.decode()}&#34;)
        return response

    def _pre_get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;get_config&#34; tasks for consistency between sync/async versions

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Building payload for `get-config` operation. source: {source}, filter_type: &#34;
            f&#34;{filter_type}, filters: {filters}&#34;
        )
        self._validate_get_config_target(source=source)

        # build base request and insert the get-config element
        xml_request = self._build_base_elem()
        xml_get_config_element = etree.fromstring(
            NetconfBaseOperations.GET_CONFIG.value.format(source=source)
        )
        xml_request.insert(0, xml_get_config_element)

        if filters is not None:
            if isinstance(filters, str):
                filters = [filters]
            xml_filter_elem = self._build_filters(filters=filters, filter_type=filter_type)
            # insert filter element into parent get element
            get_element = xml_request.find(&#34;get-config&#34;)
            # insert *after* source, otherwise juniper seems to gripe, maybe/probably others as well
            get_element.insert(1, xml_filter_elem)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `get-config` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_edit_config(
        self, config: Union[str, List[str]], target: str = &#34;running&#34;
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;edit_config&#34; tasks for consistency between sync/async versions

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(
            f&#34;Building payload for `get-config` operation. target: {target}, config: {config}&#34;
        )
        self._validate_edit_config_target(target=target)

        # build config first to ensure valid xml
        xml_config = etree.fromstring(config)

        # build base request and insert the edit-config element
        xml_request = self._build_base_elem()
        xml_edit_config_element = etree.fromstring(
            NetconfBaseOperations.EDIT_CONFIG.value.format(target=target)
        )
        xml_request.insert(0, xml_edit_config_element)

        # insert parent filter element to first position so that target stays first just for nice
        # output/readability
        edit_config_element = xml_request.find(&#34;edit-config&#34;)
        edit_config_element.insert(1, xml_config)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `edit-config` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_delete_config(self, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;edit_config&#34; tasks for consistency between sync/async versions

        Args:
            target: configuration source to target; startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(f&#34;Building payload for `delete-config` operation. target: {target}&#34;)
        self._validate_delete_config_target(target=target)

        xml_request = self._build_base_elem()
        xml_validate_element = etree.fromstring(
            NetconfBaseOperations.DELETE_CONFIG.value.format(target=target)
        )
        xml_request.insert(0, xml_validate_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `delete-config` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;commit&#34; tasks for consistency between sync/async versions

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `commit` operation&#34;)
        xml_request = self._build_base_elem()
        xml_commit_element = etree.fromstring(NetconfBaseOperations.COMMIT.value)
        xml_request.insert(0, xml_commit_element)
        channel_input = etree.tostring(xml_request)

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `commit` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;discard&#34; tasks for consistency between sync/async versions

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `discard` operation.&#34;)
        xml_request = self._build_base_elem()
        xml_commit_element = etree.fromstring(NetconfBaseOperations.DISCARD.value)
        xml_request.insert(0, xml_commit_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `discard` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;lock&#34; tasks for consistency between sync/async versions

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `lock` operation.&#34;)
        self._validate_edit_config_target(target=target)

        xml_request = self._build_base_elem()
        xml_lock_element = etree.fromstring(NetconfBaseOperations.LOCK.value.format(target=target))
        xml_request.insert(0, xml_lock_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(f&#34;Built payload for `lock` operation. Payload: {channel_input.decode()}&#34;)
        return response

    def _pre_unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;unlock&#34; tasks for consistency between sync/async versions

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `unlock` operation.&#34;)
        self._validate_edit_config_target(target=target)

        xml_request = self._build_base_elem()
        xml_lock_element = etree.fromstring(
            NetconfBaseOperations.UNLOCK.value.format(target=target)
        )
        xml_request.insert(0, xml_lock_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `unlock` operation. Payload: {channel_input.decode()}&#34;
        )
        return response

    def _pre_rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;rpc&#34; tasks for consistency between sync/async versions

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `rpc` operation.&#34;)
        xml_request = self._build_base_elem()

        # build filter element
        xml_filter_elem = etree.fromstring(filter_)

        # insert filter element
        xml_request.insert(0, xml_filter_elem)

        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(f&#34;Built payload for `rpc` operation. Payload: {channel_input.decode()}&#34;)
        return response

    def _pre_validate(self, source: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Handle pre &#34;validate&#34; tasks for consistency between sync/async versions

        Args:
            source: configuration source to validate; typically one of running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object containing all the necessary
                channel inputs (string and xml)

        Raises:
            CapabilityNotSupported: if `validate` ca

        &#34;&#34;&#34;
        self.logger.debug(&#34;Building payload for `validate` operation.&#34;)

        if not any(
            cap in self.server_capabilities
            for cap in (
                &#34;urn:ietf:params:netconf:capability:validate:1.0&#34;,
                &#34;urn:ietf:params:netconf:capability:validate:1.1&#34;,
            )
        ):
            msg = &#34;validate requested, but is not supported by the server&#34;
            self.logger.exception(msg)
            raise CapabilityNotSupported(msg)

        self._validate_edit_config_target(target=source)

        xml_request = self._build_base_elem()
        xml_validate_element = etree.fromstring(
            NetconfBaseOperations.VALIDATE.value.format(source=source)
        )
        xml_request.insert(0, xml_validate_element)
        channel_input = etree.tostring(
            element_or_tree=xml_request, xml_declaration=True, encoding=&#34;utf-8&#34;
        )

        if self.netconf_version == NetconfVersion.VERSION_1_0:
            channel_input = channel_input + b&#34;\n]]&gt;]]&gt;&#34;

        response = NetconfResponse(
            host=self.transport.host,
            channel_input=channel_input.decode(),
            xml_input=xml_request,
            netconf_version=self.netconf_version,
            strip_namespaces=self.strip_namespaces,
        )
        self.logger.debug(
            f&#34;Built payload for `validate` operation. Payload: {channel_input.decode()}&#34;
        )
        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.driver.base_driver.ScrapeBase</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="scrapli_netconf.driver.async_driver.AsyncNetconfScrape" href="async_driver.html#scrapli_netconf.driver.async_driver.AsyncNetconfScrape">AsyncNetconfScrape</a></li>
<li><a title="scrapli_netconf.driver.driver.NetconfScrape" href="driver.html#scrapli_netconf.driver.driver.NetconfScrape">NetconfScrape</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase.message_id"><code class="name">var <span class="ident">message_id</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase.netconf_version"><code class="name">var <span class="ident">netconf_version</span> : <a title="scrapli_netconf.constants.NetconfVersion" href="../constants.html#scrapli_netconf.constants.NetconfVersion">NetconfVersion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase.readable_datastores"><code class="name">var <span class="ident">readable_datastores</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase.server_capabilities"><code class="name">var <span class="ident">server_capabilities</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase.strict_datastores"><code class="name">var <span class="ident">strict_datastores</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase.strip_namespaces"><code class="name">var <span class="ident">strip_namespaces</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="scrapli_netconf.driver.base_driver.NetconfScrapeBase.writeable_datastores"><code class="name">var <span class="ident">writeable_datastores</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_netconf.driver" href="index.html">scrapli_netconf.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations">NetconfBaseOperations</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.COMMIT" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.COMMIT">COMMIT</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.DELETE_CONFIG" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.DELETE_CONFIG">DELETE_CONFIG</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.DISCARD" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.DISCARD">DISCARD</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.EDIT_CONFIG" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.EDIT_CONFIG">EDIT_CONFIG</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.FILTER_SUBTREE" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.FILTER_SUBTREE">FILTER_SUBTREE</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.FILTER_XPATH" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.FILTER_XPATH">FILTER_XPATH</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.GET" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.GET">GET</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.GET_CONFIG" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.GET_CONFIG">GET_CONFIG</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.LOCK" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.LOCK">LOCK</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.RPC" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.RPC">RPC</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.UNLOCK" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.UNLOCK">UNLOCK</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfBaseOperations.VALIDATE" href="#scrapli_netconf.driver.base_driver.NetconfBaseOperations.VALIDATE">VALIDATE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli_netconf.driver.base_driver.NetconfClientCapabilities" href="#scrapli_netconf.driver.base_driver.NetconfClientCapabilities">NetconfClientCapabilities</a></code></h4>
<ul class="">
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfClientCapabilities.CAPABILITIES_1_0" href="#scrapli_netconf.driver.base_driver.NetconfClientCapabilities.CAPABILITIES_1_0">CAPABILITIES_1_0</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfClientCapabilities.CAPABILITIES_1_1" href="#scrapli_netconf.driver.base_driver.NetconfClientCapabilities.CAPABILITIES_1_1">CAPABILITIES_1_1</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase">NetconfScrapeBase</a></code></h4>
<ul class="">
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase.message_id" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase.message_id">message_id</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase.netconf_version" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase.netconf_version">netconf_version</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase.readable_datastores" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase.readable_datastores">readable_datastores</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase.server_capabilities" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase.server_capabilities">server_capabilities</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase.strict_datastores" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase.strict_datastores">strict_datastores</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase.strip_namespaces" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase.strip_namespaces">strip_namespaces</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase.writeable_datastores" href="#scrapli_netconf.driver.base_driver.NetconfScrapeBase.writeable_datastores">writeable_datastores</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>