<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>scrapli_netconf.driver API documentation</title>
<meta name="description" content="scrapli_netconf.driver" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_netconf.driver</code></h1>
</header>
<section id="section-intro">
<p>scrapli_netconf.driver</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_netconf.driver&#34;&#34;&#34;
from scrapli_netconf.driver.async_driver import AsyncNetconfScrape
from scrapli_netconf.driver.driver import NetconfScrape

__all__ = (
    &#34;NetconfScrape&#34;,
    &#34;AsyncNetconfScrape&#34;,
)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="scrapli_netconf.driver.async_driver" href="async_driver.html">scrapli_netconf.driver.async_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli_netconf.driver.driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli_netconf.driver.base_driver" href="base_driver.html">scrapli_netconf.driver.base_driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli_netconf.driver.base_driver</p></div>
</dd>
<dt><code class="name"><a title="scrapli_netconf.driver.driver" href="driver.html">scrapli_netconf.driver.driver</a></code></dt>
<dd>
<div class="desc"><p>scrapli_netconf.driver.driver</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape"><code class="flex name class">
<span>class <span class="ident">AsyncNetconfScrape</span></span>
<span>(</span><span>port: int = 830, strip_namespaces: bool = False, strict_datastores: bool = False, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>AsyncScrape Object</p>
<p>AsyncScrape is the base class for AsyncNetworkDriver, and subsequent async platform specific
drivers (i.e. AsyncIOSXEDriver). AsyncScrape can be used on its own and offers a
semi-pexpect like experience in that it doesn't know or care about privilege levels,
platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments to pass to <code>ScrapeBase</code> &ndash; see <code>ScrapeBase</code> for available args</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TransportPluginError</code></dt>
<dd>if attempting to use a non-asyncio transport plugin</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncNetconfScrape(AsyncScrape, NetconfScrapeBase):
    def __init__(
        self,
        port: int = 830,
        strip_namespaces: bool = False,
        strict_datastores: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(port=port, **kwargs)

        if self._transport != &#34;asyncssh&#34;:
            msg = &#34;`AsyncNetconfScrape` is only supported using the `asyncssh` transport plugin&#34;
            self.logger.exception(msg)
            raise TransportPluginError(msg)

        self.transport_class = NetconfAsyncSSHTransport
        self.transport = NetconfAsyncSSHTransport(**self.transport_args)  # type: ignore
        self.channel = AsyncNetconfChannel(self.transport, **self.channel_args)

        self.strip_namespaces = strip_namespaces
        self.strict_datastores = strict_datastores
        self.server_capabilities: List[str] = []
        self.readable_datastores: List[str] = []
        self.writeable_datastores: List[str] = []
        self.netconf_version = NetconfVersion.VERSION_1_0
        self.message_id = 101

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open netconf connection to server

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        login_bytes = await self.transport.open_netconf()
        raw_server_capabilities = await (
            self.channel._get_server_capabilities(login_bytes=login_bytes)  # pylint: disable=W0212
        )

        client_capabilities = self._process_open(raw_server_capabilities=raw_server_capabilities)

        await self.channel._send_client_capabilities(  # pylint: disable=W0212
            client_capabilities=client_capabilities, capabilities_version=self.netconf_version
        )
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get operation

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get(filter_=filter_, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
        raw_response = await self.channel.send_input_netconf(response.channel_input)

        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_edit_config(config=config, target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf commit config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_commit()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf discard config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_discard()
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf lock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_lock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf unlock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_unlock(target=target)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    async def rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;rpc&#34; operation; typically only used with juniper devices

        You can also use this to build send your own payload in a more manual fashion

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_rpc(filter_=filter_)
        raw_response = await self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.driver.async_driver.AsyncScrape</li>
<li><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfScrapeBase">NetconfScrapeBase</a></li>
<li>scrapli.driver.base_driver.ScrapeBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.commit"><code class="name flex">
<span>async def <span class="ident">commit</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf commit config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def commit(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf commit config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_commit()
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.discard"><code class="name flex">
<span>async def <span class="ident">discard</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf discard config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def discard(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf discard config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_discard()
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.edit_config"><code class="name flex">
<span>async def <span class="ident">edit_config</span></span>(<span>self, config: str, target: str = 'running') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>configuration to send to device</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        config: configuration to send to device
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_edit_config(config=config, target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.get"><code class="name flex">
<span>async def <span class="ident">get</span></span>(<span>self, filter_: str, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>string filter to apply to the get</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get operation

    Args:
        filter_: string filter to apply to the get
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get(filter_=filter_, filter_type=filter_type)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.get_config"><code class="name flex">
<span>async def <span class="ident">get_config</span></span>(<span>self, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>configuration source to get; typically one of running|startup|candidate</dd>
<dt><strong><code>filters</code></strong></dt>
<dd>string or list of strings of filters to apply to configuration</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_config(
    self,
    source: str = &#34;running&#34;,
    filters: Optional[Union[str, List[str]]] = None,
    filter_type: str = &#34;subtree&#34;,
) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        source: configuration source to get; typically one of running|startup|candidate
        filters: string or list of strings of filters to apply to configuration
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
    raw_response = await self.channel.send_input_netconf(response.channel_input)

    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.lock"><code class="name flex">
<span>async def <span class="ident">lock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf lock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def lock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf lock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_lock(target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open netconf connection to server</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open netconf connection to server

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    login_bytes = await self.transport.open_netconf()
    raw_server_capabilities = await (
        self.channel._get_server_capabilities(login_bytes=login_bytes)  # pylint: disable=W0212
    )

    client_capabilities = self._process_open(raw_server_capabilities=raw_server_capabilities)

    await self.channel._send_client_capabilities(  # pylint: disable=W0212
        client_capabilities=client_capabilities, capabilities_version=self.netconf_version
    )
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.rpc"><code class="name flex">
<span>async def <span class="ident">rpc</span></span>(<span>self, filter_: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf "rpc" operation; typically only used with juniper devices</p>
<p>You can also use this to build send your own payload in a more manual fashion</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>filter/rpc to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def rpc(self, filter_: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf &#34;rpc&#34; operation; typically only used with juniper devices

    You can also use this to build send your own payload in a more manual fashion

    Args:
        filter_: filter/rpc to execute

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_rpc(filter_=filter_)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.AsyncNetconfScrape.unlock"><code class="name flex">
<span>async def <span class="ident">unlock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf unlock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unlock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf unlock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_unlock(target=target)
    raw_response = await self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape"><code class="flex name class">
<span>class <span class="ident">NetconfScrape</span></span>
<span>(</span><span>port: int = 830, strip_namespaces: bool = False, strict_datastores: bool = False, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Scrape Object</p>
<p>Scrape is the base class for NetworkDriver, and subsequent platform specific drivers (i.e.
IOSXEDriver). Scrape can be used on its own and offers a semi-pexpect like experience in
that it doesn't know or care about privilege levels, platform types, and things like that.</p>
<p><em>Note</em> most arguments passed to Scrape do not actually get assigned to the scrape object
itself, but instead are used to construct the Transport and Channel classes that Scrape
relies on, see Transport and Channel docs for details.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments to pass to <code>ScrapeBase</code> &ndash; see <code>ScrapeBase</code> for available args</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TransportPluginError</code></dt>
<dd>if attempting to use an asyncio transport plugin</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetconfScrape(Scrape, NetconfScrapeBase):
    def __init__(
        self,
        port: int = 830,
        strip_namespaces: bool = False,
        strict_datastores: bool = False,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(port=port, **kwargs)

        if self._transport != &#34;system&#34;:
            msg = &#34;`NetconfScrape` is only supported using the `system` transport plugin&#34;
            self.logger.exception(msg)
            raise TransportPluginError(msg)

        self.transport_class = NetconfSystemSSHTransport
        self.transport = NetconfSystemSSHTransport(**self.transport_args)  # type: ignore
        self.channel = NetconfChannel(self.transport, **self.channel_args)

        self.strip_namespaces = strip_namespaces
        self.strict_datastores = strict_datastores
        self.server_capabilities: List[str] = []
        self.readable_datastores: List[str] = []
        self.writeable_datastores: List[str] = []
        self.netconf_version = NetconfVersion.VERSION_1_0
        self.message_id = 101

    def open(self) -&gt; None:
        &#34;&#34;&#34;
        Open netconf connection to server

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
        login_bytes = self.transport.open_netconf()
        raw_server_capabilities = self.channel._get_server_capabilities(  # pylint: disable=W0212
            login_bytes
        )

        client_capabilities = self._process_open(raw_server_capabilities=raw_server_capabilities)

        self.channel._send_client_capabilities(  # pylint: disable=W0212
            client_capabilities=client_capabilities, capabilities_version=self.netconf_version
        )
        self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)

    def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get operation

        Args:
            filter_: string filter to apply to the get
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get(filter_=filter_, filter_type=filter_type)
        raw_response = self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    def get_config(
        self,
        source: str = &#34;running&#34;,
        filters: Optional[Union[str, List[str]]] = None,
        filter_type: str = &#34;subtree&#34;,
    ) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            source: configuration source to get; typically one of running|startup|candidate
            filters: string or list of strings of filters to apply to configuration
            filter_type: type of filter; subtree|xpath

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
        raw_response = self.channel.send_input_netconf(response.channel_input)

        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf get-config operation

        Args:
            config: configuration to send to device
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_edit_config(config=config, target=target)
        raw_response = self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    def commit(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf commit config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_commit()
        raw_response = self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    def discard(self) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf discard config operation

        Args:
            N/A

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_discard()
        raw_response = self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    def lock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf lock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_lock(target=target)
        raw_response = self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    def unlock(self, target: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf unlock operation

        Args:
            target: configuration source to target; running|startup|candidate

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_unlock(target=target)
        raw_response = self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response

    def rpc(self, filter_: str) -&gt; NetconfResponse:
        &#34;&#34;&#34;
        Netconf &#34;rpc&#34; operation; typically only used with juniper devices

        You can also use this to build send your own payload in a more manual fashion

        Args:
            filter_: filter/rpc to execute

        Returns:
            NetconfResponse: scrapli_netconf NetconfResponse object

        Raises:
            N/A

        &#34;&#34;&#34;
        response = self._pre_rpc(filter_=filter_)
        raw_response = self.channel.send_input_netconf(response.channel_input)
        response._record_response(raw_response)  # pylint: disable=W0212
        return response</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.driver.driver.Scrape</li>
<li><a title="scrapli_netconf.driver.base_driver.NetconfScrapeBase" href="base_driver.html#scrapli_netconf.driver.base_driver.NetconfScrapeBase">NetconfScrapeBase</a></li>
<li>scrapli.driver.base_driver.ScrapeBase</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli_netconf.driver.NetconfScrape.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf commit config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf commit config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_commit()
    raw_response = self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.discard"><code class="name flex">
<span>def <span class="ident">discard</span></span>(<span>self) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf discard config operation</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discard(self) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf discard config operation

    Args:
        N/A

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_discard()
    raw_response = self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.edit_config"><code class="name flex">
<span>def <span class="ident">edit_config</span></span>(<span>self, config: str, target: str = 'running') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong></dt>
<dd>configuration to send to device</dd>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_config(self, config: str, target: str = &#34;running&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        config: configuration to send to device
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_edit_config(config=config, target=target)
    raw_response = self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, filter_: str, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>string filter to apply to the get</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, filter_: str, filter_type: str = &#34;subtree&#34;) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get operation

    Args:
        filter_: string filter to apply to the get
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get(filter_=filter_, filter_type=filter_type)
    raw_response = self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self, source: str = 'running', filters: Union[str, List[str], NoneType] = None, filter_type: str = 'subtree') ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf get-config operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>source</code></strong></dt>
<dd>configuration source to get; typically one of running|startup|candidate</dd>
<dt><strong><code>filters</code></strong></dt>
<dd>string or list of strings of filters to apply to configuration</dd>
<dt><strong><code>filter_type</code></strong></dt>
<dd>type of filter; subtree|xpath</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(
    self,
    source: str = &#34;running&#34;,
    filters: Optional[Union[str, List[str]]] = None,
    filter_type: str = &#34;subtree&#34;,
) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf get-config operation

    Args:
        source: configuration source to get; typically one of running|startup|candidate
        filters: string or list of strings of filters to apply to configuration
        filter_type: type of filter; subtree|xpath

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_get_config(source=source, filters=filters, filter_type=filter_type)
    raw_response = self.channel.send_input_netconf(response.channel_input)

    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.lock"><code class="name flex">
<span>def <span class="ident">lock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf lock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf lock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_lock(target=target)
    raw_response = self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.open"><code class="name flex">
<span>def <span class="ident">open</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Open netconf connection to server</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<p>N/A
# noqa: DAR202</p>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open(self) -&gt; None:
    &#34;&#34;&#34;
    Open netconf connection to server

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.logger.info(f&#34;Opening connection to {self._initialization_args[&#39;host&#39;]}&#34;)
    login_bytes = self.transport.open_netconf()
    raw_server_capabilities = self.channel._get_server_capabilities(  # pylint: disable=W0212
        login_bytes
    )

    client_capabilities = self._process_open(raw_server_capabilities=raw_server_capabilities)

    self.channel._send_client_capabilities(  # pylint: disable=W0212
        client_capabilities=client_capabilities, capabilities_version=self.netconf_version
    )
    self.logger.info(f&#34;Connection to {self._initialization_args[&#39;host&#39;]} opened successfully&#34;)</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.rpc"><code class="name flex">
<span>def <span class="ident">rpc</span></span>(<span>self, filter_: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf "rpc" operation; typically only used with juniper devices</p>
<p>You can also use this to build send your own payload in a more manual fashion</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filter_</code></strong></dt>
<dd>filter/rpc to execute</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rpc(self, filter_: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf &#34;rpc&#34; operation; typically only used with juniper devices

    You can also use this to build send your own payload in a more manual fashion

    Args:
        filter_: filter/rpc to execute

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_rpc(filter_=filter_)
    raw_response = self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
<dt id="scrapli_netconf.driver.NetconfScrape.unlock"><code class="name flex">
<span>def <span class="ident">unlock</span></span>(<span>self, target: str) ‑> <a title="scrapli_netconf.response.NetconfResponse" href="../response.html#scrapli_netconf.response.NetconfResponse">NetconfResponse</a></span>
</code></dt>
<dd>
<div class="desc"><p>Netconf unlock operation</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong></dt>
<dd>configuration source to target; running|startup|candidate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>NetconfResponse</code></dt>
<dd>scrapli_netconf NetconfResponse object</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>N/A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unlock(self, target: str) -&gt; NetconfResponse:
    &#34;&#34;&#34;
    Netconf unlock operation

    Args:
        target: configuration source to target; running|startup|candidate

    Returns:
        NetconfResponse: scrapli_netconf NetconfResponse object

    Raises:
        N/A

    &#34;&#34;&#34;
    response = self._pre_unlock(target=target)
    raw_response = self.channel.send_input_netconf(response.channel_input)
    response._record_response(raw_response)  # pylint: disable=W0212
    return response</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_netconf" href="../index.html">scrapli_netconf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="scrapli_netconf.driver.async_driver" href="async_driver.html">scrapli_netconf.driver.async_driver</a></code></li>
<li><code><a title="scrapli_netconf.driver.base_driver" href="base_driver.html">scrapli_netconf.driver.base_driver</a></code></li>
<li><code><a title="scrapli_netconf.driver.driver" href="driver.html">scrapli_netconf.driver.driver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_netconf.driver.AsyncNetconfScrape" href="#scrapli_netconf.driver.AsyncNetconfScrape">AsyncNetconfScrape</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.commit" href="#scrapli_netconf.driver.AsyncNetconfScrape.commit">commit</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.discard" href="#scrapli_netconf.driver.AsyncNetconfScrape.discard">discard</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.edit_config" href="#scrapli_netconf.driver.AsyncNetconfScrape.edit_config">edit_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.get" href="#scrapli_netconf.driver.AsyncNetconfScrape.get">get</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.get_config" href="#scrapli_netconf.driver.AsyncNetconfScrape.get_config">get_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.lock" href="#scrapli_netconf.driver.AsyncNetconfScrape.lock">lock</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.open" href="#scrapli_netconf.driver.AsyncNetconfScrape.open">open</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.rpc" href="#scrapli_netconf.driver.AsyncNetconfScrape.rpc">rpc</a></code></li>
<li><code><a title="scrapli_netconf.driver.AsyncNetconfScrape.unlock" href="#scrapli_netconf.driver.AsyncNetconfScrape.unlock">unlock</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="scrapli_netconf.driver.NetconfScrape" href="#scrapli_netconf.driver.NetconfScrape">NetconfScrape</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli_netconf.driver.NetconfScrape.commit" href="#scrapli_netconf.driver.NetconfScrape.commit">commit</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.discard" href="#scrapli_netconf.driver.NetconfScrape.discard">discard</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.edit_config" href="#scrapli_netconf.driver.NetconfScrape.edit_config">edit_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.get" href="#scrapli_netconf.driver.NetconfScrape.get">get</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.get_config" href="#scrapli_netconf.driver.NetconfScrape.get_config">get_config</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.lock" href="#scrapli_netconf.driver.NetconfScrape.lock">lock</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.open" href="#scrapli_netconf.driver.NetconfScrape.open">open</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.rpc" href="#scrapli_netconf.driver.NetconfScrape.rpc">rpc</a></code></li>
<li><code><a title="scrapli_netconf.driver.NetconfScrape.unlock" href="#scrapli_netconf.driver.NetconfScrape.unlock">unlock</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>